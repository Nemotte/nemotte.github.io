<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/07/04/GitActionTest/"/>
      <url>/2023/07/04/GitActionTest/</url>
      
        <content type="html"><![CDATA[<h1 id="GitActionTest"><a href="#GitActionTest" class="headerlink" title="GitActionTest"></a>GitActionTest</h1><p>123</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/04/hello-world/"/>
      <url>/2023/07/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DaSE暑期夏令营实践项目--基于GitHub的博客网站</title>
      <link href="/2023/07/04/DaSE%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8EGitHub%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2023/07/04/DaSE%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8EGitHub%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="DaSE暑期夏令营实践项目–基于GitHub的博客网站"><a href="#DaSE暑期夏令营实践项目–基于GitHub的博客网站" class="headerlink" title="DaSE暑期夏令营实践项目–基于GitHub的博客网站"></a>DaSE暑期夏令营实践项目–基于GitHub的博客网站</h1><table><thead><tr><th>申请专业：大数据技术与工程</th><th>年级：2024</th><th>类别：专业型硕士</th></tr></thead><tbody><tr><td>教师：蒲鹏</td><td>姓名：金子龙</td><td>日期：2023&#x2F;07&#x2F;04</td></tr></tbody></table><h2 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h2><p>部署一个静态网页博客。静态网页博客是一种不需要后端服务器和数据库支持的网站，只需要使用 HTML、CSS 和 JavaScript 等前端技术就可以实现。静态网页博客有很多优点，比如速度快、安全稳定、易于维护等。</p><p>你需要选择一个自己感兴趣或擅长的主题来制作一个静态网页博客，比如个人介绍、爱好分享、技术总结等。你需要设计至少四个页面来展示博客内容，不限于首页、关于我、文章列表、文章详情等。</p><h2 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a>项目概览</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><p>本项目使用Hexo框架+GitHub Pages，版本信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hexo: 6.3.0</span><br><span class="line">hexo-cli: 4.3.1</span><br><span class="line">os: win32 10.0.19045</span><br><span class="line">node: 18.16.0</span><br><span class="line">acorn: 8.8.2</span><br><span class="line">ada: 1.0.4</span><br><span class="line">ares: 1.19.0</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">cldr: 42.0</span><br><span class="line">icu: 72.1</span><br><span class="line">llhttp: 6.0.10</span><br><span class="line">modules: 108</span><br><span class="line">napi: 8</span><br><span class="line">nghttp2: 1.52.0</span><br><span class="line">nghttp3: 0.7.0</span><br><span class="line">ngtcp2: 0.8.1</span><br><span class="line">openssl: 3.0.8+quic</span><br><span class="line">simdutf: 3.2.2</span><br><span class="line">tz: 2022g</span><br><span class="line">undici: 5.21.0</span><br><span class="line">unicode: 15.0</span><br><span class="line">uv: 1.44.2</span><br><span class="line">uvwasi: 0.0.15</span><br><span class="line">v8: 10.2.154.26-node.26</span><br><span class="line">zlib: 1.2.13</span><br></pre></td></tr></table></figure><p>选用的Hexo主题为Zhl，依赖的插件为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">npm install </span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hexo&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-archive&quot;</span>: <span class="string">&quot;^0.1.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-category&quot;</span>: <span class="string">&quot;^0.1.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-index&quot;</span>: <span class="string">&quot;^0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-generator-tag&quot;</span>: <span class="string">&quot;^0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;^0.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-marked&quot;</span>: <span class="string">&quot;^0.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-server&quot;</span>: <span class="string">&quot;^0.2.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hexo-browsersync&quot;</span>: <span class="string">&quot;^0.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-ejs&quot;</span>: <span class="string">&quot;^0.3.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-renderer-stylus&quot;</span>: <span class="string">&quot;^0.3.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hexo-server&quot;</span>: <span class="string">&quot;^0.2.2&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="项目布局"><a href="#项目布局" class="headerlink" title="项目布局"></a>项目布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├─node_modules</span><br><span class="line">├─public</span><br><span class="line">├─scaffolds</span><br><span class="line">├─source# 存放页面、文章</span><br><span class="line">│  ├─about# 关于页面</span><br><span class="line">│  ├─categories# 分类页面</span><br><span class="line">│  ├─game# 小游戏页面</span><br><span class="line">│  ├─lab01# 实验页面</span><br><span class="line">│  ├─lab02</span><br><span class="line">│  ├─tags# 标签页面</span><br><span class="line">│  └─_posts# 文章</span><br><span class="line">├─themes# 主题</span><br><span class="line">    └─zhl</span><br><span class="line">└─_config.yml# 全局配置</span><br></pre></td></tr></table></figure><h3 id="页面预览"><a href="#页面预览" class="headerlink" title="页面预览"></a>页面预览</h3><h4 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h4><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438.png" alt="size" style="zoom:50%;" /><h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-1.png" style="zoom:50%;" /><h4 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h4><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-2.png" style="zoom:50%;" /><h2 id="主题选取"><a href="#主题选取" class="headerlink" title="主题选取"></a>主题选取</h2><p>选用的Hexo主题为Zhl，依赖Hexo对分类、归档、标签的自动生成插件。在文章头部添加对应的分类、标签后，可以自动生成对应的分类、标签页面，在左侧小工具处可以查看。</p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-3.png" style="zoom:50%;" /><h2 id="页面实现"><a href="#页面实现" class="headerlink" title="页面实现"></a>页面实现</h2><h3 id="文章Post"><a href="#文章Post" class="headerlink" title="文章Post"></a>文章Post</h3><p>Hexo一般通过Markdown语法书写文章，通过在Markdown头部增加控制语句来设置文章页面属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 《数据库系统原理》笔记</span><br><span class="line">date: 2023-07-04 00:57:35</span><br><span class="line">categories: </span><br><span class="line">- 计科专业课笔记</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="页面Page"><a href="#页面Page" class="headerlink" title="页面Page"></a>页面Page</h3><p>Page可以用Markdown和HTML两种方式实现，以下详解HTML的实现方式。</p><h4 id="纯HTML"><a href="#纯HTML" class="headerlink" title="纯HTML"></a>纯HTML</h4><p>用命令行打开博客根目录，输入指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &lt;pagename&gt;</span><br></pre></td></tr></table></figure><p>在<code>source</code>文件夹下会新建一个<code>&lt;pagename&gt;</code>文件夹，结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├─source# 存放页面、文章</span><br><span class="line">│  ├─&lt;pagename&gt;# 页面</span><br><span class="line">|  |  └─index.md</span><br></pre></td></tr></table></figure><p>将<code>index.md</code>重命名为<code>index.html</code>，在此文件中书写HTML代码，部署后即可在对应页面浏览效果。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Tb<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.hi</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;hi&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://www.nemotte.cn/wordpress/wp-content/uploads/2022/06/test.png&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 超链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.nemotte.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Nemotte&#x27;s Blog<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 斜体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>normal text <span class="tag">&lt;<span class="name">em</span>&gt;</span>italic text<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 粗体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>normal text <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bold text<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请填写文本信息&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;cbox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;cbox1-pro&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;first_checkbox&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span>first_checkbox&lt;/label</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">name</span>=<span class="string">&quot;cbox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;cbox2-pro&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">&quot;second_checkbox&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span>second_checkbox&lt;/label</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 选择文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;radio1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio1&quot;</span> /&gt;</span>first_radio<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;radio1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio2&quot;</span> /&gt;</span>second_radio<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制范围 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多行文本编辑 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;40&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提交 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-4.png" style="zoom:50%;" /><h4 id="HTML-CSS-JS"><a href="#HTML-CSS-JS" class="headerlink" title="HTML+CSS+JS"></a>HTML+CSS+JS</h4><p>既然了解了页面部署的方式，那么任意HTML项目均可静态部署至Hexo Pages。</p><p>以下为示例结构，当然可以在<code>&lt;pagename&gt;</code>下部署任意结构的HTML项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─source# 存放页面、文章</span><br><span class="line">│  ├─&lt;pagename&gt;# 页面</span><br><span class="line">|  |  ├─index.html</span><br><span class="line">|  |  ├─temp.css</span><br><span class="line">|  |  ├─temp.js</span><br></pre></td></tr></table></figure><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-2.png" style="zoom:50%;" /><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-5.png" style="zoom:50%;" /><h2 id="GitHub-Action-自动化项目部署"><a href="#GitHub-Action-自动化项目部署" class="headerlink" title="GitHub Action 自动化项目部署"></a>GitHub Action 自动化项目部署</h2><h3 id="自动化部署概述"><a href="#自动化部署概述" class="headerlink" title="自动化部署概述"></a>自动化部署概述</h3><p>对于Hexo框架，如果要将本地文件推送到远程Git Pages上，需要依次执行如下三条指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>如需在其他设备上发布&#x2F;更新博文，则同样需要安装Hexo支撑环境，以及对应的Hexo插件，非常不便。</p><p>那么，如果在远程机器上安装好Hexo环境，通过GitHub Action直接在远程主机上执行上述三条指令，就能免去安装环境这一步骤，只需配置Git就能发布&#x2F;更新博文了。</p><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>对于Hexo框架，需要将编译后的HTML项目推送到<code>&lt;username&gt;.github.io</code>仓库中。但是我们需要新建一个仓库来保存Hexo项目源代码。</p><p>新建仓库后，将本地博客项目文件夹关联到此仓库，在<code>.github</code>文件夹下新建<code>workflow/main.yml</code>文件，输入下述配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># workflow name</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Blog</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master branch on push, auto run</span></span><br><span class="line"><span class="attr">on:</span> </span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span> </span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span> </span><br><span class="line">        </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># check it to your workflow can access it</span></span><br><span class="line">    <span class="comment"># from: https://github.com/actions/checkout</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Repository</span> <span class="string">main</span> <span class="string">branch</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@main</span> </span><br><span class="line">      </span><br><span class="line">    <span class="comment"># from: https://github.com/actions/setup-node  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="number">18.</span><span class="string">x</span> </span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@main</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&quot;18.x&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">Dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install hexo-cli -g</span></span><br><span class="line"><span class="string">        npm install</span></span><br><span class="line"><span class="string">        npm install hexo hexo-generator-archive hexo-generator-category hexo-generator-index hexo-generator-tag hexo-renderer-ejs hexo-renderer-stylus hexo-renderer-marked hexo-server --save</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span> <span class="string">Private</span> <span class="string">Key</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">HEXO_DEPLOY_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">        echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa </span></span><br><span class="line"><span class="string">        chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span> <span class="string">Infomation</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">| </span></span><br><span class="line"><span class="string">        git config --global user.name &#x27;Nemotte&#x27; </span></span><br><span class="line"><span class="string">        git config --global user.email &#x27;jinzilong312@163.com&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> </span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate </span></span><br><span class="line"><span class="string">        hexo deploy</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>这个配置的意义是，当源代码仓库接到本地的<code>push</code>指令后，自动执行<code>run</code>后面的指令。这一过程配置了远程主机的Hexo环境和依赖，并将Hexo项目推送到<code>&lt;username&gt;.github.io</code>的pages中。</p><p><strong>需要在源代码仓库中配置私钥和公钥，否则会推送失败。</strong></p><p>至此，我们在更新本地Hexo项目后，只需完成git push后，Git Pages会在Action执行后自动更新。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>我在本科期间一直有写博客的习惯。在大一的时候，自己租用了云服务器搭建Wordpress博客，并长时间使用，其中包括了各种项目和笔记。但是Wordpress博客的配置相对简单，而且操作基于图形化界面，几乎无门槛。当然，如果要完成站点的维护、页面的重排还是有门槛的，只是使用并无门槛。</p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/07/QQ截图20230704103438-6.png" style="zoom:50%;" /><p>而Hexo框架，相当于提供了主题配置+Markdown文章到HTML项目的编译功能，使用者对于项目的每一个细节都有更好的理解，可以更加简单地自定义设计和功能。并且Hexo搭建的是静态站点，加载速度明显高于Wordpress。</p><p>初学Hexo时，也碰到了很多问题，如<strong>推送至远程Page后丢失CSS格式</strong>，在全局配置中加入一行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>即可解决。</p><p>如配置GitHub Action时，<strong>远程Deploy失败</strong>，根据报错在全局配置中修改HTML URL为SSH URL即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"><span class="deletion">- repo: https://github.com/...</span></span><br><span class="line"><span class="addition">+ repo: git@github.com:...</span></span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://nemotte.github.io/">DaSE静态博客</a></p><p><a href="https://www.nemotte.cn/">Nemotte的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目报告 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《数据库系统原理》笔记</title>
      <link href="/2023/07/04/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/04/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-关系型数据库"><a href="#第一章-关系型数据库" class="headerlink" title="第一章 关系型数据库"></a>第一章 关系型数据库</h2><p>数据库系统由一个互相关联的数据集和一组用以访问这些数据的程序组成。</p><p>文件处理系统存储、组织信息弊端有下：</p><ul><li>数据的冗余和不一致</li><li>数据访问困难，对于每个新任务需要编写新的应用程序处理</li><li>数据孤立，多个文件具有不同的格式</li><li>完整性问题，完整性约束“固化”（buried）在程序代码中，很难通过修改程序来体现新的约束</li><li>原子性问题，故障会导致部分更新，使数据库处于不一致状态</li><li>并发访问异常</li><li>安全性问题</li></ul><p><strong>关系模型</strong>：表（行列）用于表示数据和数据间的联系<br><strong>实体-联系（E-R）模型</strong>：实体、联系；数据库设计<br><strong>基于对象的数据模型</strong>：E-R模型增加了封装、对象等<br><strong>半结构化数据模型</strong>：用XML来表示半结构化数据</p><p>数据抽象的三个层次：屏蔽数据结构的复杂性</p><p><strong>视图层</strong>：视图可以隐藏信息，使用户仅访问数据库的一部分，提高安全性。<br><strong>逻辑层</strong>：描述存储在数据库中的数据，以及数据之间的关系，降低耦合。<br><strong>物理层</strong>：描述数据实际上是怎样存储的。</p><p><strong>模式</strong>：数据库的总体设计。<br><strong>实例</strong>：特定时刻存储在数据库中的信息的集合。</p><p><strong>SQL: 广泛使用的非过程化（声明式）语言</strong></p><h2 id="第二章-关系模型介绍"><a href="#第二章-关系模型介绍" class="headerlink" title="第二章 关系模型介绍"></a>第二章 关系模型介绍</h2><p>关系数据库由<strong>表的集合</strong>构成。</p><h3 id="关系模式的表示"><a href="#关系模式的表示" class="headerlink" title="关系模式的表示"></a>关系模式的表示</h3><p><strong>元组</strong>：表中的一行，顺序无所谓。<br><strong>属性</strong>：必须是原子的，具有属性域。</p><p>关系模式可以表示为<code>$$R(A_1, A_2,..., A_n)$$</code>，如：</p><ul><li><code>$$instructor(ID, name, dept\_name, salary)$$</code></li><li><code>$$department (dept\_name, building, budget)$$</code></li></ul><p>在关系模式中，使用相同属性可以将不同关系的元组联系起来。</p><h3 id="元组中的码"><a href="#元组中的码" class="headerlink" title="元组中的码"></a>元组中的码</h3><p><strong>超码</strong>：若<code>$$K$$</code>能唯一标识关系<code>$$r(R)$$</code>中的一个元组，则<code>$$K$$</code>是关系<code>$$r(R)$$</code>的超码。<br>超码作为元组，可以是<strong>一个或者多个属性的集合</strong>。</p><p><strong>候选码</strong>：任何真子集都不能成为超码的最小超码称为候选码。</p><p>选择值很少或者从不变化的候选码作为主码。</p><p><strong>外码</strong>：一个关系模式r1在其属性上包含另一个关系模式r2的主码，这个属性在r1上称为参照r2的外码。r1称为外码依赖的<strong>参照关系</strong>，r2称为外码的<strong>被参照关系</strong>。</p><p><strong>参照完整性约束</strong>：参照关系中的任意元组在特定属性（如外码）上的取值，必须等于被参照关系中的某个元组在该特定属性上的取值。</p><p><strong>模式图</strong>：</p><ul><li>每一个关系模式用一个矩形来表示</li><li>主码属性用下划线标注</li><li>外码约束（依赖）用从参照关系的外码到被参照关系的主码之间的箭头表示</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20220919131918.png"></p><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>六个基本关系运算：</p><ul><li>选择 <code>$$\sigma$$</code></li><li>投影 <code>$$\Pi$$</code></li><li>集合并 <code>$$\cup$$</code></li><li>集合差 <code>$$-$$</code></li><li>笛卡尔积 <code>$$×$$</code></li><li>更名 <code>$$\rho$$</code></li></ul><p>此外，集合交、自然连接和赋值运算可以用以上基本运算来定义。</p><h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h4><p>选择满足给定谓词条件的元组。<br><code>$$\sigma_&#123;dept\_name=&#39;Physics&#39;&#125;(instructor)$$</code></p><h4 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h4><p>过滤掉特定属性。<br><code>$$\Pi_&#123;ID,name,salary&#125;(instructor)$$</code>，只选择instructor表的指定三列。</p><h4 id="笛卡尔积运算"><a href="#笛卡尔积运算" class="headerlink" title="笛卡尔积运算"></a>笛卡尔积运算</h4><p>结合来自任意两个关系的信息。<br>两个关系的所有元组一对n行配对。相同的属性名可能同时出现在两个表中。如果重名，需要加入表的名字作为属性前缀。</p><h4 id="运算的组合"><a href="#运算的组合" class="headerlink" title="运算的组合"></a>运算的组合</h4><p>可以使用多种运算构建表达式。<br><code>$$\sigma_&#123;A=C&#125;(r×s)$$</code>，将r和s表连接。</p><h4 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h4><p><code>$$r\bowtie_&#123;\theta&#125;s=\sigma_&#123;\theta&#125;(r×s)$$</code></p><h4 id="集合并运算"><a href="#集合并运算" class="headerlink" title="集合并运算"></a>集合并运算</h4><p><code>$$r\cup s$$</code><br>要求r和s必须同元，属性数量和属性域必须相同。</p><h4 id="集合差运算"><a href="#集合差运算" class="headerlink" title="集合差运算"></a>集合差运算</h4><p><code>$$r-s$$</code><br>要求r和s必须同元，属性数量和属性域必须相同。</p><h4 id="查询举例"><a href="#查询举例" class="headerlink" title="查询举例"></a>查询举例</h4><p>利用大学模式，找出最高工资。<br><code>$$\Pi_&#123;salary&#125;(instructor)-\Pi_&#123;instructor.salary&#125;(\sigma_&#123;instructor.salary &lt; d.salary&#125;(instructor × \rho_&#123;d&#125;(instructor)))$$</code></p><h2 id="第三章-SQL基础"><a href="#第三章-SQL基础" class="headerlink" title="第三章 SQL基础"></a>第三章 SQL基础</h2><h3 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h3><p>SQL的DDL能够定义每个关系的信息，包括：</p><ul><li>关系的模式</li><li>属性的取值类型，取值范围</li><li>完整性约束</li><li>关系的安全性和权限信息</li><li>每个关系维护的索引集合</li><li>每个关系在磁盘上的物理存储结构</li></ul><h3 id="SQL的基本类型"><a href="#SQL的基本类型" class="headerlink" title="SQL的基本类型"></a>SQL的基本类型</h3><p>SQL的常用基本类型包括：</p><ul><li>char(n): 固定长度的字符串，用户指定长度n</li><li>varchar(n): 可变长度字符串，用户指定最大长度n</li><li>int: 整数类型 (4字节)</li><li>smallint: 小整数类型 (2字节)</li><li>numeric(p,d): 定点数，精度由用户指定。这个数有p位数字，其中，d位数字在小数点右边</li><li>real, double precision: 浮点数与双精度浮点数，精度与机器相关</li><li>float(n): 精度至少为n位的浮点数</li></ul><h3 id="基本关系模式的定义"><a href="#基本关系模式的定义" class="headerlink" title="基本关系模式的定义"></a>基本关系模式的定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> instructor(</span><br><span class="line">ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_namt <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">primary</span> key(ID),</span><br><span class="line"><span class="keyword">foreign</span> key(dept_name) <span class="keyword">references</span> department</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>SQL<strong>禁止破坏完整性约束的数据库更新</strong>，例如：</p><ul><li>新插入元组的主码为空值或重复</li><li>新插入instructor元组的dept_name未出现在department关系中，破坏外码约束</li></ul><h3 id="删除和修改表"><a href="#删除和修改表" class="headerlink" title="删除和修改表"></a>删除和修改表</h3><p><strong>drop table</strong>：删除表和其中内容。<br><strong>delete from</strong>：删除表内容，但是保留关系模式。<br><strong>alter table R add&#x2F;drop A</strong>：增加或删除属性。<br>许多数据库都不支持删除属性，但支持drop整个表。</p><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A,B,C</span><br><span class="line"><span class="keyword">from</span> r,m</span><br><span class="line"><span class="keyword">where</span> P1 <span class="keyword">and</span><span class="operator">/</span><span class="keyword">or</span><span class="operator">/</span>not... P2;</span><br></pre></td></tr></table></figure><p>ABC代表属性，rm代表关系，P是谓词（限定条件）。</p><p>例如大学模式中，查找所有教师的名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>SQL语句是不区分大小写的。</p><h4 id="all-x2F-distinct"><a href="#all-x2F-distinct" class="headerlink" title="all&#x2F;distinct"></a>all&#x2F;distinct</h4><p>SQL在查询结果和关系中默认允许重复。为了强制消除重复，在select后加上关键字<strong>distinct</strong>。</p><h4 id="属性的运算"><a href="#属性的运算" class="headerlink" title="属性的运算"></a>属性的运算</h4><p>selec子句可以包含算术表达式，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span></span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p>where子句表示结果满足的必须限定条件。<br>例如找出Comp.Sci系中工资大于80000教师的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Come.Sci&#x27;</span> <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">80000</span>;</span><br></pre></td></tr></table></figure><h4 id="from分句"><a href="#from分句" class="headerlink" title="from分句"></a>from分句</h4><p>from中可以用逗号隔开多个关系，表示多个关系间的笛卡尔积。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instuctor, teaches;</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>接上一小节，如果要去除无效属性，则需要用where子句选择出属性名和属性均相同的元组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID;</span><br></pre></td></tr></table></figure><p><strong>如果省略where子句，则谓词P为true。</strong></p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>在连接的基础上，去除重复属性列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches;</span><br></pre></td></tr></table></figure><h4 id="更名运算"><a href="#更名运算" class="headerlink" title="更名运算"></a>更名运算</h4><p>SQL允许对关系和属性进行更名操作。</p><p>使用as子句更改属性名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">as</span> monthly_salary</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>使用as子句更改关系名（as可以省略）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp.Sci&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><p>SQL的like运算符可以实现模式匹配：</p><ul><li>百分号匹配任意字符串</li><li>下划线匹配任意一个字符</li></ul><p>SQL字符串使用单引号，关系代数的字符串使用双引号。<br>SQL的匹配模式是大小写敏感的。</p><p>‘intro%’匹配以intro开头的字符串。<br>‘%Comp%’匹配包含Comp子串的字符串。<br>‘___‘匹配只含三个字符的字符串。<br>‘___%’匹配至少包含三个字符的字符串。</p><p>例如，找出姓名中包含dar的教师的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%dar%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="元组的排序"><a href="#元组的排序" class="headerlink" title="元组的排序"></a>元组的排序</h4><p>使用order by A，令查询结果按照属性A排序。<br>可以用desc表示降序，asc表示升序，省略则按照asc排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>排序可以在多个属性上进行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_name <span class="keyword">desc</span>, name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h4 id="where子句谓词"><a href="#where子句谓词" class="headerlink" title="where子句谓词"></a>where子句谓词</h4><p>SQL提供between运算。<br>例如找出工资在90000和100000之间的教师姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>元组比较符可以比较属性组成的元组，但是不建议使用。</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>union表示并，intersect表示交，except表示差。<br>集合操作自动消除冗余，如果要保留冗余，需要在运算关键字后面加上all。</p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>属性为空可以以null表示它的值。</p><p>使用null的谓词可以测试空值：</p><ul><li>is null</li><li>is not null</li></ul><p><strong>任何与null的算术表达式结果为null。</strong><br><strong>任何空值的比较运算表达式结果为unknown。</strong></p><h4 id="unknown逻辑表达式"><a href="#unknown逻辑表达式" class="headerlink" title="unknown逻辑表达式"></a>unknown逻辑表达式</h4><p>四个特例：</p><ul><li>unknown or false &#x3D; unknown</li><li>unknown and false &#x3D; false</li><li>not unknown &#x3D; unknown</li><li>unknown is unknown &#x3D; true</li></ul><p>如果where子句的谓词结果为unknown，可以当作false处理。</p><p>如果元组在除了null值外的所有属性上取值相等，那么它们可以视为相同元组。<br>但是这样的元组用逻辑等于运算后，结果为unknown。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数包括：</p><ul><li>avg</li><li>min</li><li>max</li><li>sum</li><li>count</li></ul><p>其中，sum和avg的输入必须是数字集。</p><p>例如：<br>找出Comp.Sci教师的平均工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp.Sci&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="分组聚集"><a href="#分组聚集" class="headerlink" title="分组聚集"></a>分组聚集</h3><p>查询每个学院的平均工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><p>在select子句中出现，但是不在group by子句中出现的属性，只能出现在聚集函数内部。</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>在查询中调用另一个有特定限制的关系时，可以使用嵌套子查询。</p><h4 id="空关系测试"><a href="#空关系测试" class="headerlink" title="空关系测试"></a>空关系测试</h4><p>用于测试一个子查询结果是否存在元组，关键字exists。</p><p>例如查询在2009年秋季学期和2010年春季学期同时开课的所有课程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span> <span class="keyword">and</span></span><br><span class="line"><span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">from</span> section <span class="keyword">as</span> T</span><br><span class="line">   <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span> <span class="keyword">and</span> S.course_id <span class="operator">=</span> T.course_id);</span><br></pre></td></tr></table></figure><p>可以使用not exists（B except A)表示关系A中元组集合包含关系B的元组集合。</p><p>例如：找出选修了Biology系开设的所有课程的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>((<span class="keyword">select</span> course_id</span><br><span class="line">  <span class="keyword">from</span> course</span><br><span class="line">  <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>)</span><br><span class="line"> <span class="keyword">except</span></span><br><span class="line"> (<span class="keyword">select</span> T.course_id</span><br><span class="line"> <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line"> <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID));</span><br></pre></td></tr></table></figure><h4 id="from子查询"><a href="#from子查询" class="headerlink" title="from子查询"></a>from子查询</h4><p>注意，如果子查询需要使用having子句的条件，一般写在父查询的where子句中。</p><p>lateral关键字：使得from子句中的子查询使用来自其他关系的相关变量。</p><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>该子查询返回包含单个属性的单个元组。</p><h4 id="不带from子句的标量"><a href="#不带from子句的标量" class="headerlink" title="不带from子句的标量"></a>不带from子句的标量</h4><p>例如，查询平均每位教师所讲授的课程段数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> teaches)<span class="operator">/</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> instructor)</span><br></pre></td></tr></table></figure><h3 id="数据库的修改"><a href="#数据库的修改" class="headerlink" title="数据库的修改"></a>数据库的修改</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除所有在位于Watson大楼的系工作的教师。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span> (<span class="keyword">select</span> dept_name <span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span>);</span><br></pre></td></tr></table></figure><p>当删除操作对查询过程的表达式产生影响时，SQL采用一种解决方案：</p><ul><li>先计算</li><li>再删除（无需重新计算或者测试）</li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>在插入表格的内容来源于本表格时，应当先执行select语句，再执行插入。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>给工资超过100000的教师涨3%的工资,其余教师涨5%。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> <span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">then</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">else</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="第四章-中级SQL"><a href="#第四章-中级SQL" class="headerlink" title="第四章 中级SQL"></a>第四章 中级SQL</h2><h3 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式"></a>连接表达式</h3><p>连接操作以两个关系为输入，将另一个关系作为结果返回。</p><p>加入course和prereq中均有course_ids属性，则以下查询等价：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">natural</span> <span class="keyword">join</span> prereq;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> course <span class="keyword">join</span> prereq <span class="keyword">using</span>(course_id);</span><br></pre></td></tr></table></figure><p>要求保留重复的属性，以下查询等价：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">join</span> prereq <span class="keyword">on</span> course.course_id <span class="operator">=</span> prereq.course_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> course, prereq</span><br><span class="line"><span class="keyword">where</span> course.course_id <span class="operator">=</span> prereq.course_id;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接是连接的扩展，可以避免因为连接导致的操作结果信息的丢失。</p><p>外连接的过程：先执行连接操作，然后将两个关系中不匹配的元组都加入到最后的结果关系中，并使用null作为属性值补全。</p><p>连接操作默认为内连接。</p><p>左外连接保留第一个关系模式的所有元组，右外连接保留第二个关系模式的所有元组。全外连接则全部保留。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在某些情况下，用户对关系的访问需要加以控制。视图提供了向用户隐藏特定数据的机制。</p><p>一旦定义了视图，就可以用视图名指代该视图生成的虚关系。<br><strong>视图定义会导致一个表达式被存储</strong>，当使用这个视图时，查询过程中这个表达式将会被代入使用。、</p><p>例如：<br>创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> faculty</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> departments_total_salary(dept_name, total_salary) <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure><p>一个视图可能被用到定义另一个视图的表达式中，如果视图v2用于v1的定义中，我们称<strong>v1直接依赖v2</strong>。<br>如果v1直接依赖v2或者从v1到v2有一条依赖路径，我们称<strong>v1依赖v2</strong>。<br>如果一个视图v依赖其自身，我们称该视图v是<strong>递归的</strong>。</p><p><strong>视图展开</strong>：递归地将语句中所有的视图替换为它所存储的表达式。只要涉及到的所有视图的定义不是递归的，视图就可以被展开。</p><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>特定数据库系统允许师徒关系被存储，当实际关系改变时，视图也随之更改，这样的视图称为物化视图。<br>维护一个物化视图需要将实际关系的改变应用到视图中。</p><h4 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h4><p>考虑faculty关系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>如果要插入元组，那么插入操作必须被描述为对关系instructor的操作。<br>考虑下述插入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> faculty</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><p>对于此语句，数据库有两种处理方法：</p><ul><li>拒绝插入</li><li>插入(‘30765’, ‘Green’, ‘Music’, null)，因为instructor还有一项salary属性</li></ul><p>更为复杂的情况，考虑下述视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> instructor_info <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ID, name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name<span class="operator">=</span> department.dept_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor_info <span class="keyword">values</span>(<span class="string">&#x27;69987&#x27;</span>,<span class="string">&#x27;White&#x27;</span>,<span class="string">&#x27;Taylor&#x27;</span>);</span><br></pre></td></tr></table></figure><p>由于插入的属性分别位于两个关系模式中，只能在instructor表中插入(‘69987’,’White’,null,null)，在department中插入(‘null’,’Taylor’,null)。<strong>但是由这两张表构建出来的视图还是不存在元组（’69987’,’White’,’Taylor’)。</strong></p><p>一般情况下，不允许对视图关系进行更新。<br>如果定义视图的查询语句对下列条件都能满足，我们称SQL视图是可（插入）更新的：</p><ul><li>from子句只有一个关系</li><li>select子句只包含关系的属性名，不包含任何表达式，聚集函数或distinct生命</li><li>任何没有出现在select子句中的属性内容可以取空值</li><li>查询不包含group by，having</li></ul><h5 id="更新带条件的视图"><a href="#更新带条件的视图" class="headerlink" title="更新带条件的视图"></a>更新带条件的视图</h5><p>考虑下述视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> history_instructors <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;History&#x27;</span>;</span><br></pre></td></tr></table></figure><p>数据库允许向history_instructor插入(‘25566’,’Brown’,’Biology’,100000)，即使创建视图时的条件是dept_name &#x3D; ‘History’。</p><p>视图定义的时候，可以加入with check option子句，可以拒绝不满足视图where子句条件的元组更新和插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> history_instructors <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name<span class="operator">=</span> <span class="string">&#x27;History&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务（Transaction）由查询和（或）更新语句的序列组成。<br>事务的开始是隐式的，以commit或rollback结束一个事务。其中commit指令提交事务，并持久保存事务所做的更新。rollback回滚当前事务，撤销事务的更新。</p><p>事务具有<strong>ACID特性</strong>：</p><ul><li>原子性：要么事务的<strong>所有影响被反映到数据库中</strong>，要么在回滚之后不产生任何影响；</li><li>一致性：事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，<strong>数据库都必须处于一致性状态</strong>。如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态；</li><li>隔离性：事务的隔离性是指在<strong>并发环境</strong>中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰；</li><li>持久性：一旦事务提交，那么它对数据库中的对应数据的状态的变更就会<strong>永久保存到数据库中</strong>。即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。</li></ul><p>在大多数数据库中：每个SQL语句默认为一个事务，自动提交。也可以通过begin atomic end将多条语句视为一个事务。</p><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><p>完整性约束防止的是<strong>对数据的意外破坏</strong>，它保证授权用户对数据库所做的修改不会破坏数据的一致性。</p><h4 id="实体完整性约束"><a href="#实体完整性约束" class="headerlink" title="实体完整性约束"></a>实体完整性约束</h4><p>实体完整性约束保证关系中的每个元组都是可识别的和唯一的：</p><ul><li>not null：声明属性不可为空</li><li>unique：指出属性（组）形成一个超码，但是允许为null</li><li>check：是的关系中的每个元组都必须满足谓词P</li></ul><h4 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h4><p>参照完整性约束一般是指多个实体或关系之间的关联关系，用于描述实体之间的联系。</p><p><strong>用户自定义完整性约束（域完整性或语义完整性约束）</strong>：关系中属性的取值范围，避免属性的值与应用语义的矛盾。它保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现。</p><p><strong>外键</strong>：若r1.k1参照的属性集r2.k2为所属关系r2的主键，则称k1为参照关系r2.k2的外键。</p><h5 id="参照完整性中的级联操作"><a href="#参照完整性中的级联操作" class="headerlink" title="参照完整性中的级联操作"></a>参照完整性中的级联操作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> key(dept_name) <span class="keyword">references</span> department</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表示在department中删除某个元组后，在course中也删除参照被参照的已删除元组。</p><p>将cascade替换为set null, set default，表示在department中删除某个元组，即将course中参照被删除系置空或置为默认值。</p><p><strong>外码可以为null，值为null的外码自动被认为满足约束。</strong></p><p>如何在不违反完整性约束的情况下插入一个元组:</p><ul><li>先将配偶信息设为null，在插入配偶元组后再更新该配偶信息（当配偶信息设为not null 时，该操作不可行）</li><li>推迟完整性约束检查到事务结束时进行</li></ul><h4 id="复杂Check条件与断言"><a href="#复杂Check条件与断言" class="headerlink" title="复杂Check条件与断言"></a>复杂Check条件与断言</h4><p>断言就是一个谓词，它表达了我们希望数据库总能满足的一个条件；属性域约束和参照完整性约束是断言的特殊形式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>assertion<span class="operator">-</span>name<span class="operator">&gt;</span> <span class="keyword">check</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="SQL的数据类型和模式"><a href="#SQL的数据类型和模式" class="headerlink" title="SQL的数据类型和模式"></a>SQL的数据类型和模式</h3><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>使用后表达式：cast(e as t)将表达式e转换为类型t。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(ID <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">5</span>)) <span class="keyword">as</span> inst_id</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> inst_id;</span><br></pre></td></tr></table></figure><p>coalesce()函数可以解决输出空值的情况，该函数接收任意相同数量的参数，并返回第一个非空参数。</p><p>在DDL定义关系时，default关键字可以定义属性的默认值。</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index studentID_index <span class="keyword">on</span> student(ID);</span><br></pre></td></tr></table></figure><h4 id="大对象类型"><a href="#大对象类型" class="headerlink" title="大对象类型"></a>大对象类型</h4><p>blob：二进制大对象。<br>clob：字符大对象。</p><h4 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">budget Dollars</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>drop type删除类型，alter type更改类型。</p><h4 id="域"><a href="#域" class="headerlink" title="域"></a>域</h4><p>域类型是可以有约束和默认值的用户自定义类型。<br>基本类型相容的一个域类型的值可以被赋给另一个域类型。</p><h3 id="模式、目录与环境"><a href="#模式、目录与环境" class="headerlink" title="模式、目录与环境"></a>模式、目录与环境</h3><p>数据库系统提供三层结构的关系命名机制：目录&#x2F;模式&#x2F;关系、视图。</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>数据库在数据上的权限：</p><ul><li>select 允许读取</li><li>insert 允许插入</li><li>update 允许修改</li><li>delete 允许删除</li></ul><p>数据库在模式上的权限：</p><ul><li>index 允许创建、删除索引</li><li>resources 允许创建新的关系</li><li>alteration 允许添加或删除关系中的属性</li><li>drop 允许删除关系</li></ul><h4 id="授权规范"><a href="#授权规范" class="headerlink" title="授权规范"></a>授权规范</h4><p>对视图的授权并不代表对视图相关的实际关系的授权；权限授予人必须已经具有对指定项目的权限（或者是数据库管理员）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> instructor <span class="keyword">to</span> U1,U2,U3;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(salary) <span class="keyword">on</span> instructor <span class="keyword">to</span> U1, U2, U3;</span><br></pre></td></tr></table></figure><p>with grant option字段允许被授权的用户将此权限授予其他用户。</p><h4 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">update</span>(budget) <span class="keyword">on</span> department <span class="keyword">from</span> U1,U2,U3;</span><br></pre></td></tr></table></figure><p>默认级联收回权限（cascade），如果使用restrict关键字，可以避免一些不合适的权限级联收回。</p><p>如果某些权限被不同的授权者授予同一个用户两次，那么在一次权限回收后该用户可能仍保有这个权限；一个权限被回收后，基于这一权限的其他权限（如视图）也将被回收。</p><h4 id="角色Role"><a href="#角色Role" class="headerlink" title="角色Role"></a>角色Role</h4><p>权限可以被授予给角色：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> takes <span class="keyword">to</span> instructor;</span><br></pre></td></tr></table></figure><p>角色可以被授予给用户，同时也能被授予给其他角色：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> instructor <span class="keyword">to</span> Amit;</span><br><span class="line"><span class="keyword">create</span> role TA;</span><br><span class="line"><span class="keyword">grant</span> TA <span class="keyword">to</span> instructor;</span><br></pre></td></tr></table></figure><h4 id="模式授权"><a href="#模式授权" class="headerlink" title="模式授权"></a>模式授权</h4><p>SQL标准为数据库模式指定了一种基本的授权机制：只有模式的拥有者才能够执行对模式的任何修改。</p><p>SQL提供了references权限，允许用户在创建关系时声明外码。这个权限能够避免没有ref权限的用户创建参照联系，从而引发限制其他用户操作的行为。</p><h2 id="第七章-数据库设计和E-R模型"><a href="#第七章-数据库设计和E-R模型" class="headerlink" title="第七章 数据库设计和E-R模型"></a>第七章 数据库设计和E-R模型</h2><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p><strong>概念设计阶段</strong>：构建E-R图<br><strong>逻辑设计阶段</strong>：将E-R图映射到关系模式<br><strong>物理设计阶段</strong>：指明数据库文件组织格式和索引结构</p><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>E-R模型是一种语义模型，在将现实世界事物的含义和相互关联映射到概念模式方面非常有用。</p><p>E-R模型采用三个基本概念：</p><ul><li>实体集</li><li>联系集</li><li>属性</li></ul><p>一个数据库可以被建模为：</p><ul><li>实体的集合</li><li>实体间的联系</li></ul><h4 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h4><p>实体是现实世界可区别于所有其他对象的一个“事物”或“对象”，实体集则是实体的集合。</p><p>实体有属性，它是实体集中每个成员所拥有的描述性性质。<br>每个实体的每个属性都有一个值。</p><h4 id="联系集"><a href="#联系集" class="headerlink" title="联系集"></a>联系集</h4><p>联系指多个实体之间的相互关联。</p><p>实体在联系中扮演的功能称为实体的角色。<br>当同样的实体集参与一个联系集多于一次，这类联系集称作是<strong>递归联系集</strong>。</p><h5 id="联系集的度"><a href="#联系集的度" class="headerlink" title="联系集的度"></a>联系集的度</h5><p>参与联系集的实体集数目称为联系集的度。</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射基数约束"><a href="#映射基数约束" class="headerlink" title="映射基数约束"></a>映射基数约束</h4><p>映射基数，又叫基数比率，表示一个实体通过一个联系集能关联的实体个数。</p><h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>如果实体集E中的每个实体都参与到联系集R的至少一个联系中，实体集E在联系集R中的参与称为<strong>全部</strong>的。</p><p>如果实体集E中只有部分实体参与，则称E部分参与R。</p><h4 id="联系集的超码"><a href="#联系集的超码" class="headerlink" title="联系集的超码"></a>联系集的超码</h4><p>由相关实体集的主码构成的集合。</p><h4 id="冗余属性"><a href="#冗余属性" class="headerlink" title="冗余属性"></a>冗余属性</h4><p>假如有实体集instructor，department和联系集inst_dept，instructor中有dept_name属性，那么这个属性就是冗余的，因为有一个明确的联系关系。</p><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p>矩阵代表实体集，属性在实体矩阵中列出，构成主码的属性用下划线表明，菱形代表联系集。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20221130195113.png"></p><h5 id="参与联系集中的实体集"><a href="#参与联系集中的实体集" class="headerlink" title="参与联系集中的实体集"></a>参与联系集中的实体集</h5><p>全部参与用两条线表示。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20221130195113-1.png"></p><h5 id="具有属性的联系集"><a href="#具有属性的联系集" class="headerlink" title="具有属性的联系集"></a>具有属性的联系集</h5><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20221130195113-2.png"></p><h5 id="基数约束联系集表示"><a href="#基数约束联系集表示" class="headerlink" title="基数约束联系集表示"></a>基数约束联系集表示</h5><p>我们在联系集和实体集之间画一个箭头(→)代表“一”或者一条线段(—)代表“多”来表示基数约束。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20221130195113-3.png"></p><h5 id="有三元联系的E-R图"><a href="#有三元联系的E-R图" class="headerlink" title="有三元联系的E-R图"></a>有三元联系的E-R图</h5><p>我们只允许在一个三元（或三元以上）联系集外有一个箭头来表示基数约束。如果多于一个箭头，会有多种解释导致歧义。</p><h5 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h5><p>没有足够属性形成主码的实体集叫做<strong>弱实体集</strong>。<br>弱实体集必须与标识或属主实体集关联才有意义。<br>将弱实体集与其标识实体集相连的联系称为标识性联系。</p><p>弱实体集通过一个全部参与的、（多对一或一对一）的联系集与标识实体集联系。</p><p>弱实体集的主码由标识实体集的主码和该弱实体集的分辨符（部分码）共同组成。</p><p>弱实体集的分辨符用虚下划线表示。</p><p>强实体集的主码并不存储于弱实体集，如果存入弱实体集，会导致属性的重复存储。</p><h3 id="E-R模型转化为关系模式"><a href="#E-R模型转化为关系模式" class="headerlink" title="E-R模型转化为关系模式"></a>E-R模型转化为关系模式</h3><p>实体集和联系集都可以用表示数据库内容的统一的关系模式来表示；<br>每个实体集和联系集都有一个特有的关系模式与其对应，并分配相应的名字；<br>每个关系模式都有一些列（通常对应属性），每个列都有唯一的名字；</p><h4 id="模式的冗余"><a href="#模式的冗余" class="headerlink" title="模式的冗余"></a>模式的冗余</h4><p>多对一和一对多的联系集的模式，如果<strong>“多”方参与是全部的</strong>，那么可以将“多”方实体集和联系集的模式合并成单个包含两个模式所有属性并集的关系模式。</p><p>比如模式instructor,department，教师和学院的基数约束是多对一的，并且全部教师参与与学院的联系。因此可以将department的主码dept_name加入instructor，并添加外码约束。这样就可而已少建立一个联系集。</p><p>如果<strong>“多”方参与是部分的</strong>，也可以通过使用空值来进行模式合并。转换为关系模式时，联系集中“一”方的相关属性应注意不能设为not null。</p><p>在<strong>一对一</strong>联系的情况下，联系集的关系模式可以跟参与联系的任何一个实体集的模式进行合并。</p><h3 id="扩展的E-R特性"><a href="#扩展的E-R特性" class="headerlink" title="扩展的E-R特性"></a>扩展的E-R特性</h3><h4 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h4><p>在实体集内部进行分组的过程称为<strong>特化</strong>。</p><p>子集中的实体在某些方面区别于实体集中的其他实体，这些子集成为了较低层的实体集，可能具有高层实体集不具有的属性、或者参与到高层实体集不参与的联系集中。</p><p>特化通过从特化实体指向另一个实体的空心箭头来表示 (e.g., instructor “is a” person)</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20221130195113-4.png"></p><h4 id="概化"><a href="#概化" class="headerlink" title="概化"></a>概化</h4><p>概化是高层实体集与一个或多个低层实体集间的包含关系。</p><p><strong>不相交</strong>：一个实体至多属于一个低层实体集。<br><strong>重叠</strong>：同一个实体可同时属于同一概化的多个低层实体集。</p><p><strong>完全性约束</strong>：定义高层实体集中的一个实体是否必须属于该概化的至少一个低层实体集。<br><strong>全部</strong>：必须属于一个；<br><strong>部分</strong>：不加限制；</p><p>默认情况是部分概化。</p><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><p>为不引入冗余，用聚集来表示E-R模型。</p><h2 id="第八章-关系数据库设计"><a href="#第八章-关系数据库设计" class="headerlink" title="第八章 关系数据库设计"></a>第八章 关系数据库设计</h2><h3 id="好的关系设计的特点"><a href="#好的关系设计的特点" class="headerlink" title="好的关系设计的特点"></a>好的关系设计的特点</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>考虑department(dept_name, building, budget)关系，主键是dept_name，即dept_name可以确定(building, budget)，即保持函数依赖：dept_name -&gt; building, budget。</p><h4 id="有损分解"><a href="#有损分解" class="headerlink" title="有损分解"></a>有损分解</h4><p>无法通过自然连接重建原始关系元组的分解为有损分解。</p><p>考虑这种情况，将employee(ID, name, street, city, salary)分解为employee_attr1(ID, name)，employee_attr2(name, street, city, salary)。<br>其中name无法作为第二个关系的主码，因为可能有重名。这时候将attr1，attr2自然连接，无法得出原始的关系。</p><h3 id="函数依赖-1"><a href="#函数依赖-1" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>假设r(R)是一个关系模式，a,b是R上的属性。<br>则R上的函数依赖<code>$$a\rightarrow b$$</code>成立的条件是，如果对于任意关系实例r中的两个任意元组<code>$$t_1,t_2$$</code>，如果两者的属性a相同，则它们的属性b相同。<br>函数依赖<code>$$a\rightarrow b$$</code>称为a函数确定b，或者b函数依赖于a。</p><p>函数依赖允许我们表达超码不能表达的约束。</p><p>如果关系实例r在函数依赖集F上合法，则称r满足F。如果模式R上的所有合法关系实例都满足函数依赖集F，我们说F在关系模式R上成立。</p><p>有些函数依赖被称为<strong>平凡</strong>的，因为它们在所有关系中都是满足的。<br>例如：</p><ul><li>name -&gt; name</li><li>ID, name -&gt; ID</li></ul><p>通常，如果属性集<code>$$b\subseteq a$$</code>，那么a-&gt;b就是平凡的函数依赖。</p><p>a-&gt;b，则这里的a是决定因素。</p><p>函数依赖a-&gt;b称为部分依赖的条件是：存在a的真子集c，使得c-&gt;b。</p><p>函数依赖集F能够推导出的所有函数依赖的集合，我们称之为F集合的闭包，记作<code>$$F+$$</code>。</p><h4 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h4><p>给定关系模式r(R)，如果r(R)的每个满足F的实例也满足某个函数依赖f，则R上的函数依赖f逻辑蕴含（logically imply）于r上的函数依赖集F。</p><h4 id="计算函数依赖集闭包算法"><a href="#计算函数依赖集闭包算法" class="headerlink" title="计算函数依赖集闭包算法"></a>计算函数依赖集闭包算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F+ = F</span><br><span class="line">repeat</span><br><span class="line">for each F+中的函数依赖f</span><br><span class="line">在f上应用自反律和增补律</span><br><span class="line">将结果加入到F+中</span><br><span class="line">for each F+中的一对函数依赖f1和f2</span><br><span class="line">if f1和f2 可以使用传递律结合</span><br><span class="line">将结果加入F+中</span><br><span class="line">until F+不变</span><br></pre></td></tr></table></figure><h4 id="属性闭包"><a href="#属性闭包" class="headerlink" title="属性闭包"></a>属性闭包</h4><p>属性集a在函数依赖集F下，由属性a函数确定的所有属性集合叫做F下a的闭包，记为<code>$$a+$$</code>。</p><p>属性闭包可以判断属性是否是超码，验证函数依赖，计算F的闭包。</p><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><h4 id="规范化的目标"><a href="#规范化的目标" class="headerlink" title="规范化的目标"></a>规范化的目标</h4><p>令每个关系模式都是好的模式：无数据冗余。<br>分解是无损分解，保持依赖。</p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><h5 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h5><p>如果一个关系模式R的所有属性域都是原子的，那么R是1NF。</p><p>非原子的值会造成复杂存储及数据冗余。</p><h5 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h5><p>在1NF基础上，F+中每一个非主属性完全函数依赖于候选码，则R是2NF。</p><h5 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h5><p>在2NF基础上，对所有F+中的函数依赖<code>$$a\rightarrow b$$</code>，如果b不是a的子集，那么a一定是R的一个超码。</p><p>排除了任何属性（包括主属性和非主属性）对候选码的部分依赖和传递依赖，也排除了主属性之间的传递依赖。</p><p>如果F上的每一个函数依赖都在其分解后的一个关系上成立，那么这个分解是保持依赖的，但是BCNF分解通常不保持依赖，因此增加检查约束的开销。所以考虑3NF。</p><p><strong>将模式分解为BCNF</strong>：假设有模式R，及其一个非平凡依赖<code>$$a\rightarrow b$$</code>不属于BCNF，那么可以将R分解成：<code>$$(a\cup b),(R-(b-a))$$</code>，如果分解后的模式仍然不符合BCNF，那么继续按照上述方法分解，直到每个模式都属于BCNF为止。</p><p><strong>BCNF的问题</strong>：检查约束的开销很大，但是如果只涉及到单个关系，检查约束的开销就相对较低。但是BCNF的分解会导致原模式的某些函数依赖的检查开销变大。<br>比如对于模式<code>$$(sid, iid, dept)$$</code>，函数<code>$$iid\rightarrow dept; sid, dept \rightarrow iid$$</code>成立。观察到函数<code>$$iid \rightarrow dept$$</code>不符合BCNF，因为根据上述函数依赖，唯一超码为<code>$$(sid,dept)$$</code>。所以根据BCNF分解规则，将模式分解为<code>$$a\cup b:(iid, dept); R-(b-a):(sid, iid)$$</code>。<br>然而，函数依赖<code>$$sid, dept \rightarrow iid$$</code>在新的两个模式中间的验证，需要在两个模式的连接运算后检查。因此这种分解是<strong>不保持依赖</strong>的。所以需要设计一种保持依赖的，较BCNF更加宽松的范式。</p><h5 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h5><p>3NF比起BCNF，对所有F+中的函数依赖多了一个可选成立条件：b-a中的每个属性A都包含在R的候选码中。</p><p>第三个条件是BCNF的一个最小放宽：即允许存在主属性对候选码的传递依赖和部分依赖，在函数依赖集F中用来满足保持某些函数依赖。</p><p>也就是说，具有函数依赖集F的关系模式R属于3NF，则R的任何非主属性既不部分依赖于码，也不传递依赖于码。</p><p><strong>例</strong>：对于关系模式R(S,C,P)，S表示学生，C表示课程，P表示成绩，判断R属于哪一种范式。</p><ol><li>易得R属于1NF；</li><li>对于关系模式R，写出R的函数依赖集F<code>$$\&#123;(S,C)\rightarrow P, (C,P)\rightarrow S\&#125;$$</code>，F+&#x3D;F。因此R的候选码为：(S,C),(C,P)，主属性为：S,C,P。由于不存在非主属性，所以R属于2NF；</li><li>对于F+中任意非平凡的X→Y，所有的X都是R的一个候选码（超码），所以R属于BCNF；</li></ol><p><strong>例</strong>：对于关系模式R(S,T,C)，S表示学生，T表示教师，C表示课程，规定每个教师只教一门课，判断R属于哪一种范式。</p><ol><li>易得R属于1NF；</li><li>对于关系模式R，写出R的函数依赖集F<code>$$\&#123;T\rightarrow C, (S,C)\rightarrow T, (S,T)\rightarrow C\&#125;$$</code>，并且F+&#x3D;F。因此R的候选码为(S,C),(S,T)，主属性为：S,T,C。由于不存在非主属性，所以R属于2NF；</li><li>对于F+中非平凡的X→Y，其中T→C中的T不是候选码，所以R不属于BCNF；</li><li>对于函数依赖T→C，C包含于R的候选码，所以R属于3NF。</li></ol><h5 id="BCNF的缺陷"><a href="#BCNF的缺陷" class="headerlink" title="BCNF的缺陷"></a>BCNF的缺陷</h5><p>BCNF不是一个足够好的关系模式，考虑关系<code>$$inst_info(ID, ChildName, tel)$$</code>，其中一个inst可以有很多个孩子和电话。<br>对于这个关系模式，不存在任何非平凡的函数依赖，所以它是BCNF。但是当要对某个ID新建一个电话号码的时候，需要插入他孩子数量的元组。因此存在由多值依赖造成的信息冗余。这里需要4NF来规范关系模式。</p><h3 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h3><h4 id="正则覆盖"><a href="#正则覆盖" class="headerlink" title="正则覆盖"></a>正则覆盖</h4><p>F的正则覆盖<code>$$F_c$$</code>不存在任何的冗余依赖或冗余的部分依赖。并且和F具有相同的依赖集闭包F+。</p><h5 id="无关属性"><a href="#无关属性" class="headerlink" title="无关属性"></a>无关属性</h5><p><strong>无关属性的形式化定义</strong>：对于函数依赖集F和其中的函数依赖a→b，如果</p><ul><li>对于属性<code>$$A\in a$$</code>，F逻辑蕴涵<code>$$(F-(a\rightarrow b))\cup ((a-A)\rightarrow b)$$</code></li><li>对于属性<code>$$B\in b$$</code>，F逻辑蕴涵<code>$$(F-(a\rightarrow b))\cup (a\rightarrow (b-B))$$</code><br>那么其中的A是a中的无关属性，B是b中的无关属性。</li></ul><p><strong>无关属性的验证</strong>：考虑函数依赖集F和F中的函数依赖a→b</p><ul><li>为了验证属性<code>$$A\in a$$</code>是否多余，使用F中的函数依赖计算属性集闭包(a-A)+，验证其是否包含b，如果包含，那么A是无关属性</li><li>为了验证属性<code>$$B\in b$$</code>是否多余，使用函数依赖集<code>$$(F-a\rightarrow b)\cup a\rightarrow(b-B)$$</code>计算a+，验证其是否包含B，如果包含则无关</li></ul><h5 id="计算F的正则覆盖算法"><a href="#计算F的正则覆盖算法" class="headerlink" title="计算F的正则覆盖算法"></a>计算F的正则覆盖算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fc=F;</span><br><span class="line">repeat</span><br><span class="line">使用合并律将Fc中的依赖合并；</span><br><span class="line">再Fc中将包含无关属性的函数依赖中的无关属性从依赖中删除</span><br><span class="line">until Fc不变</span><br></pre></td></tr></table></figure><p>在删除了某些无关属性后可能需要使用合并律，因此合并律会重复应用。</p><p>F的正则覆盖Fc是一个函数依赖集，具有如下特性：</p><ul><li>F逻辑蕴涵Fc中的所有函数依赖</li><li>Fc逻辑蕴涵F中的所有函数依赖</li><li>Fc中的任何函数依赖都不含无关属性</li><li>Fc中的函数依赖左部都是不同的</li></ul><h4 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h4><p>将模式R分解成R1，R2。如果R1和R2的交集属性是R1或R2的超码，那么称这个分解是无损的。</p><h4 id="保持依赖"><a href="#保持依赖" class="headerlink" title="保持依赖"></a>保持依赖</h4><p>如果分解的模式的函数依赖集的并集的闭包，和原来函数依赖集F的闭包相同，那么说这种分解是保持依赖的。</p><h5 id="保持依赖的检验"><a href="#保持依赖的检验" class="headerlink" title="保持依赖的检验"></a>保持依赖的检验</h5><p>对F中的每一个函数依赖，检测其是否被分解后的模式保持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = a;</span><br><span class="line">while (result变化) do</span><br><span class="line">for each 分解后的Ri</span><br><span class="line">t = (result \cap Ri)+ \cap Ri</span><br><span class="line">result = result \cup t</span><br></pre></td></tr></table></figure><p>如果最后result包含b中的所有属性，那么函数依赖a→b被保持。<br>这个方法的好处在于，没有计算F在Ri上的限定，直接使用F上的属性闭包。</p><h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><h4 id="BCNF简化判定"><a href="#BCNF简化判定" class="headerlink" title="BCNF简化判定"></a>BCNF简化判定</h4><p>要检查关系模式R是否属于BCNF，仅需检查给定集合F中的函数依赖是否违反BCNF即可，不许检查F+。因为如果F中没有违反BCNF的函数依赖，F+也不会有。</p><p>但是，在检测由关系R分解后的关系Ri是否满足BCNF范式时，只使用F是不正确的。</p><h4 id="3NF分解"><a href="#3NF分解" class="headerlink" title="3NF分解"></a>3NF分解</h4><p>3NF的分解有以下结论：</p><ul><li>允许冗余</li><li>函数依赖可以不连接，在单个关系上检验</li><li>总是能够在无损分解和保持依赖的情况下分解成3NF</li></ul><h5 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h5><p>两个问题，信息重复和空值。<br>考虑模式d_a(sid, iid, d_n)，表示学生，导师和专业的关系。存在<code>$$F=\&#123;sid d\_n\rightarrow iid, iid \rightarrow d\_n\&#125;$$</code>，那么对于一个导师，可能有很多他的学生，这就导致导师和专业的信息重复；对于没有学生的导师，需要对sid设置为空值。</p><h5 id="3NF的验证"><a href="#3NF的验证" class="headerlink" title="3NF的验证"></a>3NF的验证</h5><p>用属性闭包验证每个依赖a→b，判断a是否是超码；如果a不是超码，验证b-a中的每个属性被R的一个候选码包含。</p><p>因为要找到候选码，所以验证花销很大。是个NP难问题。但是3NF的分解可以在多项式时间内完成。</p><h2 id="第十章-存储管理"><a href="#第十章-存储管理" class="headerlink" title="第十章 存储管理"></a>第十章 存储管理</h2><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>数据库是以一系列文件的形式存储的。每个文件在逻辑上组织成为<strong>记录的一个序列</strong>。<br>每个文件分为定长的存储单元，称为块（block），块是存储分配和数据传输的基本单元，块大小一般为4-8KB。<br>记录在文件中可以是定长的或是变长的。</p><h4 id="定长记录"><a href="#定长记录" class="headerlink" title="定长记录"></a>定长记录</h4><p>记录i从n(i-1)个字节开始存储，n是每个记录的大小。<br>假定每个记录都被完全包含在单个块中，不允许记录跨越块的边界。</p><p>删除第i个记录的可选方案：</p><ul><li>后面的记录前移</li><li>将最后的记录放到位置i</li><li>不移动记录，在空闲列表中列出空闲记录位</li></ul><h5 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h5><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230202121050.png"></p><p>对于每个文件，分配特定数量的字节来增添一个文件头，将第一个删除的记录的地址存储在文件头。<br>如果删除第二个记录，那么就将第二个记录的地址存放在第一个被删除的记录里，后续的删除操作以此类推。<br>于是被删除的记录形成了一个链表，被称为<strong>自由链表</strong>。</p><p>如果需要插入一条新记录，就将内容存放在文件头指向的记录中，并改变文件头的指针，使其指向下一个空闲记录位。如果没有空闲记录位，则将新纪录添加在文件末尾。</p><h4 id="变长记录"><a href="#变长记录" class="headerlink" title="变长记录"></a>变长记录</h4><p>变长记录以下面几种方式出现在数据库系统中：</p><ul><li>多种记录类型存储在一个文件中</li><li>允许一个或多个字段是变长的记录类型</li><li>允许可重复字段的记录类型</li></ul><p>具有变长属性的记录通常包含两个部分：</p><ul><li>带有定长信息的初始部分</li><li>变长属性的内容</li></ul><p>变长属性在初始部分中被表示为一个（偏移量，长度）对，其中偏移量表示在记录中该属性的数据开始的位置，二长度表示变长属性字节长度。</p><p>在记录初始定长的部分之后，变长属性的值是连续存储的。<br>记录末尾加上记录终止符。</p><h5 id="分槽的页结构"><a href="#分槽的页结构" class="headerlink" title="分槽的页结构"></a>分槽的页结构</h5><p>分槽页的块头包含：</p><ul><li>块中记录的条目的个数</li><li>块中空闲空间的末尾处</li><li>一个由包含记录位置和大小的记录条目组成的数组</li></ul><p>记录从块的末尾开始连续地分配空间，自由空间位于块头和记录中间。插入新记录时，在空闲空间的尾部分配空间，并将这条记录的大小和位置作为一项加入块头数组中。</p><p>如果记录被删除，它所占用的空间被释放，项被置为deleted，块中位于被删除记录前的记录将被向后移动，使空闲空间连续。</p><h3 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h3><p><strong>堆文件组织</strong>：只要空间足够，一个记录可以放在文件的任何地方。<br><strong>顺序文件组织</strong>：记录根据搜索码的值顺序存储。<br><strong>散列文件组织</strong>：在每条记录上的某些属性上计算一个散列函数，根据函数值确定记录应该放入哪个块。</p><p>通常，每个关系的记录用一个单独的文件存储。</p><p>但是多表聚簇文件组织中，几个不同关系的记录存储在同一个<br>文件中，目的在于在同一块中存储相关记录，以将I&#x2F;O代价减到最小。</p><h4 id="顺序文件组织"><a href="#顺序文件组织" class="headerlink" title="顺序文件组织"></a>顺序文件组织</h4><p>适用于需要对整个文件进行顺序处理的应用，每个记录包含搜索码，按照搜索码排列。</p><p>所有的记录以链表的方式存储，对于删除操作，使用指针链即可。对于插入操作，如果在<strong>插入位置的所在块</strong>有空闲空间，那么插入到空闲处；如果没有空闲空间，那么将新记录插入溢出块。两种方式均需要重新调整指针，使链表按照搜索码排列。</p><h4 id="多表聚簇文件组织"><a href="#多表聚簇文件组织" class="headerlink" title="多表聚簇文件组织"></a>多表聚簇文件组织</h4><p>在一个文件中存储多个关系。</p><p>能够很好地处理多个关系的连接查询。对于下图，在CompSci下方的，Physics上方的教师都是CompSci系的。由于每个系是不连续存储的，所以要添加指针链，对只涉及系的查询效果不好。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749.png"></p><h3 id="数据字典存储"><a href="#数据字典存储" class="headerlink" title="数据字典存储"></a>数据字典存储</h3><p><strong>数据字典</strong>：也叫系统目录存储元数据（关于数据的数据）</p><p>它存储：</p><ul><li>关系的信息</li><li><ul><li>关系的名字</li></ul></li><li><ul><li>每个关系属性的名字、类型和长度</li></ul></li><li><ul><li>视图定义</li></ul></li><li><ul><li>完整性约束</li></ul></li><li>用户的账户信息</li><li>统计和描述性数据</li><li><ul><li>每个关系中的元组数目</li></ul></li><li>物理文件组织信息</li><li><ul><li>关系如何存储</li></ul></li><li><ul><li>关系的物理位置</li></ul></li><li>索引的信息</li></ul><p>系统元数据是为在内存中进行高效访问而设计的特殊数据结构。</p><h3 id="数据缓冲区"><a href="#数据缓冲区" class="headerlink" title="数据缓冲区"></a>数据缓冲区</h3><h4 id="存储访问"><a href="#存储访问" class="headerlink" title="存储访问"></a>存储访问</h4><p>每个文件分成定长的存储单元，称为块。块是存储分配和数据传输的基本单位。</p><p>数据库系统的一个主要目标就是<strong>减少磁盘和存储器之间传输的块数</strong>。减少磁盘访问次数的一种方法是在主存储器中保留尽可能多的块。</p><p><strong>缓冲区</strong>：主存储器中用于存储磁盘块的副本的那一部分。<br><strong>缓冲区管理器</strong>：负责缓冲区空间分配的子系统。</p><h5 id="缓冲区管理器"><a href="#缓冲区管理器" class="headerlink" title="缓冲区管理器"></a>缓冲区管理器</h5><p>程序需要磁盘上的块时，可以向缓冲区管理器发出请求</p><ol><li>如果这个块已经在缓冲区中，缓冲区管理器将这个块在主存储器中的地址传给请求者</li><li>如果这个块不在缓冲区中，缓冲区管理器<br>a. 在缓冲区中为这个块分配空间<br>① 如果需要的话，会把其他块移出主存储器，为这个新块腾出空间<br>② 移出的块仅当它自从最近一次写回磁盘后被修改过，才被写回磁盘<br>b. 把这个块从磁盘读入缓冲区，并将这个块在主存储器中的地址传给请求者</li></ol><p>大多数操作系统使用最近最少使用策略 (least recently used ，LRU)<br>当涉及对<strong>数据重复扫描的访问模式</strong>时，LRU是一个糟糕的策略。<br>由查询优化器提供的带有提示的混合替换策略是较好的选择：</p><ul><li>被钉住的块：不允许写回磁盘的块</li><li>立即丢弃：一旦块中的最后一个元组被处理完毕，立刻命令缓冲区管理器释放这个块所占用的空间</li><li>最近最常使用：系统替换最近一直使用的块，当块的最后一个元组处理完毕后，块被解除钉住，最近最常使用的块被移除</li></ul><p>缓冲区管理器可以使用请求访问某个特定关系的统计信息<br>例如：数据字典被经常访问<br>因此：将数据字典的块保留在主存储器的缓存中</p><p>为保证数据可恢复性，缓冲区管理器也支持块的强制写出到磁<br>盘。</p><h2 id="第十一章-索引"><a href="#第十一章-索引" class="headerlink" title="第十一章 索引"></a>第十一章 索引</h2><p>索引机制用于加速对所需数据的访问，类比于图书馆的作者目录。</p><p><strong>搜索码</strong>：用于在文件中查找记录的属性或属性集。</p><p>一个索引文件包含索引项（搜索码值，记录指针）。<br>索引文件一般比原文件小很多。</p><p>两个基本类型索引：</p><ul><li>顺序索引：按搜索码顺序存储索引</li><li>散列索引：使用散列函数将搜索码平均分布到若干散列桶中（一般作为辅助索引）</li></ul><p><strong>索引技术评价指标</strong>：</p><ul><li>能支持的访问类型</li><li>访问时间</li><li>插入时间</li><li>删除时间</li><li>空间开销</li></ul><h3 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h3><p><strong>顺序索引</strong>：按顺序存储搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。</p><p><strong>主索引</strong>: 顺序文件组织中，索引的搜索码指定了文件中记录的顺序（一个关系只有一个），也叫聚集索引。主索引的搜索码一般是主码，但不是必须的。</p><p><strong>辅助索引</strong>: 搜索码指定的顺序与文件中记录的物理顺序不同的索引（一个关系可以有多个），也叫非聚集索引。</p><p><strong>索引顺序文件</strong>: 在搜索码上有聚集索引的文件（若记录按搜索码顺序排列）。</p><p><strong>稠密索引</strong>：文件中的每个搜索码值都有一个索引记录。</p><p><strong>稠密聚集索引</strong>：文件中不同的元组可能有重复的搜索码，对于重复的搜索码的索引，一个索引可能对应多个元组。元组按照聚集的属性，相同的排列在一起。</p><p><strong>稀疏索引</strong>：只为搜索码的某些值建立索引记录。在记录按照搜索码顺序排列时适用。</p><p>稠密索引与稀疏索引对比：</p><ul><li>稀疏索引插入和删除时所需的空间及维护开销较小</li><li>稀疏索引定位一条记录的速度比较慢</li></ul><p>好的折中方案：为每个块建一个索引项（块起始搜索码）的稀疏索引。</p><p><strong>多级索引</strong>：将主索引以顺序文件的形式放于磁盘，并为之建立一个稀疏索引。防止主索引太大无法放入主存。</p><p>如果外层索引还是太大，那么就可以再建另外一级索引，以此类推；对文件进行插入或删除操作后，所有级别的索引都需要更新。</p><p>通常，我们希望找到某一特定字段（非主索引的搜索码）符合某些条件的所有记录。<br>例1：关系instructor按照ID顺序存储，我们希望找到某一特殊领域内的所有教师<br>例2：和上面相同的情况，但是我们希望找出符合给定薪水值或薪水范围的所有教师</p><p>我们可以使用一个辅助索引，每个搜索码值都有一个索引记录（稠密索引）</p><p>索引记录指向包含所有指向具有特定搜索键值的实际记录的指针，辅助索引必须是稠密的，即不可能存在辅助稀疏索引。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-1.png"></p><p>索引的更新会给数据库的修改带来额外的开销，每当文件被修改时，这个文件上的每个索引都要更新。</p><p>使用主索引进行顺序扫描是很高效的，但是使用辅助索引却花费很大。因为：</p><ul><li>每次对记录的访问都可能从磁盘获得一个新块</li><li>获取新块需要5到10毫秒，而存储器访问只需要100纳秒</li></ul><h4 id="多码索引"><a href="#多码索引" class="headerlink" title="多码索引"></a>多码索引</h4><p>复合搜索码是指包含不止一个属性的搜索码。</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>使用顺序索引的缺点：</p><ul><li>性能随着文件的增长而下降，因为创建了许多溢出块</li><li>需要定期重组整个文件</li></ul><p>B+树索引文件的优势：</p><ul><li>在面对插入和删除时，使用小的局部更改自动重组</li><li>不需要重组整个文件来保持查询性能</li></ul><p>B+树索引缺点：</p><ul><li>额外的插入和删除开销，空间开销</li></ul><h4 id="B-树结构"><a href="#B-树结构" class="headerlink" title="B+树结构"></a>B+树结构</h4><p>B+树是一种平衡树，也就是说它所有从根到叶的路径长度都相同。<br>对于一棵B+树，有一个特定的值n，对于n：</p><ul><li>每个非叶节点（除根节点外）都有<code>$$\lceil n/2 \rceil$$</code>到n个子节点</li><li>一个叶节点内可包含搜索码的数量在<code>$$\lceil (n-1)/2 \rceil$$</code>到n-1之间</li></ul><p>如果根节点是一个非叶节点，则它至少有两个子节点；<br>如果根节点是一个叶子节点，则它可以有0到（n-1）个值（即搜索码）。</p><p>在B+树的节点中，搜索码是按顺序排序的。指针域位于搜索码的左侧。</p><p>B+树的叶子节点具有如下属性：</p><ul><li>指针Pi指向具有搜索值为Ki的记录</li><li>叶子节点的搜索码值从左到右升序排列</li><li>Pn按搜索键的顺序指向下一个叶子节点</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-2.png"></p><p>B+树的非叶子节点形成了对叶子节点的一个多级（稀疏）索引。对于带有m个指针（m称为扇出）的非叶节点：</p><ul><li>P1所在的子树中的所有搜索码都小于K1</li><li>Pn所在的子树中的所有搜索键的值大于或等于Kn–1</li><li>对于其他指针，Pi所在子树的所有搜索码的值大于或等于Ki–1、且小于Ki</li></ul><h4 id="B-树特性"><a href="#B-树特性" class="headerlink" title="B+树特性"></a>B+树特性</h4><p>B+树形成了一个稀疏索引的层次结构；<br>B+树可以用相对较少的层次来表示大量的搜索码</p><p>因此，如果索引文件中有K个搜索键值，则树的高度（即搜索路径长度）不超过<code>$$\lceil log_&#123;\lceil n/2 \rceil&#125;(K)\rceil $$</code></p><p>可以有效地处理对主文件的插入和删除。因为B+树索引可以在有限时间内（与树的高度成正比关系）进行有效重构。</p><h4 id="B-树查询"><a href="#B-树查询" class="headerlink" title="B+树查询"></a>B+树查询</h4><p>典型B+树的节点规模通常与磁盘块的大小相同，通常取值为4KB，因此n取值为100左右。<br>对于有100万个搜索码的索引文件、且n&#x3D;100，则最多查询log50(1,000,000) &#x3D; 4 个节点（4个块），即可完成从根到叶子节点的遍历。</p><h3 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h3><p>B树只允许搜索码出现一次，消除了搜索键的冗余存储。</p><p>非叶节点中的搜索码在B树中没有其他位置可出现，因此，必须为非叶节点中的每个搜索键包含一个<strong>额外的指针字段（需指向文件记录）</strong>。</p><p>B树的优点：</p><ul><li>可能比相应的B+树使用更少的节点</li><li>有时可以在到达叶节点之前找到搜索码</li></ul><p>B树的缺点：（数据库的范围查找效率低）</p><ul><li>在所有搜索码中，只有一小部分被早期找到</li><li>非叶节点需存储搜索码的记录指针，所以扇出相应地（fanout）变小了。因此，B树通常比B+树具有更大的深度</li><li>插入和删除比B+树更复杂</li><li>实现比B+树更难</li></ul><h3 id="散列索引"><a href="#散列索引" class="headerlink" title="散列索引"></a>散列索引</h3><p>桶是能存储一条或多条记录的一个存储单元(一个桶就是一个磁盘块)，在散列文件组织中，通过使用散列函数直接从搜索码中获得包含该记录的桶。</p><p>散列函数h是一个从K到B的函数。K表示所有搜索码值的集合，B表示所有桶地址的集合。</p><p>散列函数用来为获取、插入和删除操作定位记录。<br>具有不同搜索码值的记录可能映射到同一个桶，因此<strong>整个桶都要被顺序搜索来定位记录</strong>。</p><p>散列索引无法支持<strong>范围查询</strong>。</p><p>桶溢出可以减少，但是不能消除。</p><h4 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h4><p>所有溢出桶用一个链表链接在一起。</p><h4 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h4><p>没有溢出链，一个桶满后将记录插入到其他桶中。</p><h3 id="SQL创建索引"><a href="#SQL创建索引" class="headerlink" title="SQL创建索引"></a>SQL创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(<span class="operator">&lt;</span>element_list<span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure><p>使用create unique index直接声明该搜索码是一个候选码。</p><h3 id="SQL撤销索引"><a href="#SQL撤销索引" class="headerlink" title="SQL撤销索引"></a>SQL撤销索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>大多数数据库允许指定索引类型，并声明聚集索引。</p><h2 id="第十三章-事务管理"><a href="#第十三章-事务管理" class="headerlink" title="第十三章 事务管理"></a>第十三章 事务管理</h2><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>事务是构成单一逻辑工作单元的操作集合。<br>事务是访问并可能更新各种数据项的一个程序执行单元。<br>事务由事务开始（begin transaction）与事务结束（end transaction）之间执行的全体操作组成。</p><p>事务管理主要处理的两个问题：</p><ul><li>各类故障恢复，如硬件故障，系统崩溃</li><li>多个事务的并发执行</li></ul><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p>为了保证数据的完整性，数据库系统必须保证：</p><ul><li>原子性：事务的所有操作在数据库中要么全部反应，要么完全不反应；</li><li>一致性：事务隔离执行时保持数据库的一致性；</li><li>隔离性：多个事务可能并发执行，但是单个事务的执行过程中感受不到其他事务在并发执行；例如两个事务Ti和Tj，对于Ti，Tj要么在Ti开始之前完成了执行，要么在Ti结束后开始执行；</li><li>持久性：一个事务成功完成后，它对数据库的更改是永久的，即使系统出现故障。</li></ul><h4 id="事务原子性和持久性"><a href="#事务原子性和持久性" class="headerlink" title="事务原子性和持久性"></a>事务原子性和持久性</h4><p>事务状态：</p><ul><li>活动的：初始状态，事务执行时处于这个状态</li><li>部分提交的：最后一条语句执行后</li><li>失败的：发现正常的执行不能继续后</li><li>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后。中止后可以重新开始事务或者杀死事务</li><li>已提交的：成功完成执行的事务，如果想撤销影响需要新建执行一个补偿事务</li></ul><h4 id="事务隔离性"><a href="#事务隔离性" class="headerlink" title="事务隔离性"></a>事务隔离性</h4><p>事务处理系统通常允许多个事务并发地执行。优点是:</p><ul><li>提高吞吐量和资源利用率</li><li>减少等待时间</li></ul><p>通过并发控制机制来实现事务隔离性，它控制并发执行的事务之间的相互作用，来避免他们破坏数据库的一致性。</p><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>调度即指令执行顺序，指定并发执行事务的指令执行的时间顺序。<br>一组事务的一个调度必须包含这一组事务的全部指令；必须保持指令在各个事务中出现的顺序。</p><p>一个事务成功执行后，会有一条指令作为最后的声明，事务默认提交指令commit为其最后一条指令。</p><p>一个事务没有成功完成时，会用一条中止指令abort来作为最后的声明。</p><h4 id="SQL的事务定义"><a href="#SQL的事务定义" class="headerlink" title="SQL的事务定义"></a>SQL的事务定义</h4><p>SQL标准规定事务的开始是隐式的。<br>事务的结束用下列SQL语句之一来表示：</p><ul><li>Commit [work]：提交当前事务并开始一个新的事务</li><li>Rollback [work]：回滚当前事务</li></ul><p>在几乎所有的数据库系统中，缺省每个SQL语句如果成功执行的话，也立即隐式提交事务。<br>这种隐式提交也可以通过数据库指令关闭。</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>基本假设：每个事务都能保持数据库的一致性<br>事务的串行执行是可以保持一致性的<br>如果一个调度等价于一个串行调度，那么这个调度就是可串行化的</p><p>按调度的不同形式可分为:</p><ol><li>冲突可串行化（重点关注）</li><li>视图可串行化</li></ol><p><strong>简化视图</strong>：只考虑read和write指令。假设事务在read和write指令之间可以对本地缓冲区的数据进行任意的操作。</p><p>两条属于不同事务的连续指令，当数据项被两条指令同时访问，并且至少有一个指令执行write操作时产生冲突。</p><p>两条冲突的指令之间必须有一个逻辑时间顺序。如果两条指令在时间上连续且不发生冲突，那么可以交换这两条指令的顺序。</p><p>如果调度S可以通过一系列非冲突指令交换转化成S’，则这两个调度是<strong>冲突等价</strong>的。</p><p>若一个调度S与一个可串行调度冲突等价，则称调度S是<strong>冲突可串行化</strong>的。</p><h3 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h3><p><strong>可恢复调度</strong>：如果Ti读取了之前由Tj所写的数据项，则Tj须先于Ti提交。</p><p>下图是一个不可恢复的调度。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-3.png"></p><p><strong>级联回滚</strong>：因单个事务故障导致一系列事务回滚。</p><p><strong>无级联调度</strong>：对于每对事务Ti和Tj，如果Ti读取了之前由Tj所写的数据项，则Tj须先于Ti的这一读取操作提交。这种调度不会发生级联回滚。</p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>调度的目标是：</p><ul><li>冲突可串行化</li><li>可恢复性，最好是无级联</li></ul><p>并发控制则是建立一个能够保证串行化的并发控制协议。</p><h4 id="SQL-92中的并发级别"><a href="#SQL-92中的并发级别" class="headerlink" title="SQL-92中的并发级别"></a>SQL-92中的并发级别</h4><p><strong>可串行化</strong>：通常保证可串行化的执行。<br><strong>可重复读</strong>：只允许毒已提交的数据，一个事务对相同数据的重复读取要返回相同的值。<br><strong>已提交读</strong>：（默认）只允许读取已提交的数据，但不要求可重复读。<br><strong>未提交读</strong>：允许读取未提交数据。</p><p>以上所有隔离级别都不允许<strong>脏写</strong>：即一个数据项被一个尚未提交或中止的事务写入，它不允许被任何其他事务执行写操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level serializable</span><br></pre></td></tr></table></figure><h4 id="基于锁的协议"><a href="#基于锁的协议" class="headerlink" title="基于锁的协议"></a>基于锁的协议</h4><p>锁是用来控制对数据项的并发访问的一种机制。</p><p>给数据加锁有两种方式：</p><ul><li>排他锁，对数据项可写可读 lock-X</li><li>共享锁，对数据项只能读 lock-S</li></ul><p>unlock释放锁</p><p>申请锁请求发送给并发控制管理器，只有在管理器授予锁后，事务才能继续其操作。</p><p><strong>锁相容矩阵</strong>：<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-4.png"></p><ul><li>如果被请求锁与数据项上已有的锁相容，那么事务可以被授予该锁</li><li>一个数据项可以同时有多个共享锁</li><li>如果一个事务在某个数据项上拥有排他锁，那么其他事务不能再在这个数据项上加任何锁</li><li>如果一个锁不能被授予，那么请求该锁的事务必须等待，直到该数据项上的其他不相容锁全部释放，然后再被授予锁</li></ul><p><strong>封锁协议</strong>：一组规定事务何时对数据项进行加锁、解锁的规则。封锁协议限制了可能的调度数目。</p><p>考虑这个调度：<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-5.png"></p><p>排他锁lock-S(B)导致T4等待T3释放其在B上的X锁，共享锁lock-X(A)导致T3等待T4释放其在A上的S锁。<br>这种情况称为死锁，必须回滚并释放锁，否则调度无法进行。</p><p>大多数封锁协议都会产生死锁。</p><p><strong>饿死</strong>：T2对一个数据项施加共享锁，此时T1事务想要在同一数据项上加上排他锁，那么就需要等候T2事务释放共享锁。然而一个事务序列{T3…Tn}对这一数据项申请共享锁的操作是不需要阻塞的，如果申请共享锁的事务过多，则T1会迟迟得不到调度。这种现象称为饿死。</p><p>避免事务饿死的授权加锁方式：当事务Ti申请对数据项Q加M型锁时，并发控制管理器授权加锁的条件须满足：</p><ol><li>不存在在数据项Q上持有与M型锁冲突的锁的其他事务</li><li>不存在等待对数据项Q加锁且先于Ti申请加锁的事务</li></ol><p><strong>封锁协议</strong>：令T0-Tn是参与调度S的一个事务集，如果对于数据项Q，Ti在Q上持有A型锁，而后Tj在Q上持有B型锁，且Comp(A,B)&#x3D;false，那么Ti先于Tj，记为Ti→Tj。这意味着任何等价的串行调度中，Ti必须出现在Tj前。</p><p>如果调度S是遵从封锁协议规则的可能调度置一，则它是合法的。</p><p>一个封锁协议当且仅当其所有合法的调度为冲突可串行化时，我们称它保证冲突可串行性；换句话说，对于任何合法的调度，其关联的事务优先关系是无循环的。</p><h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>阶段1：增长阶段，即事务只能获得锁，不能释放锁。<br>阶段2：缩减阶段，即事务只能释放锁，不能获得锁。</p><p>封锁点：在调度中该事务获得其最后加锁的位置。（增长阶段结束点）</p><p>两阶段封锁协议保证可串行化：可以证明事务可以按照封锁点排序。</p><p>两阶段封锁不能保证不发生死锁，可能出现级联回滚。</p><p>严格两阶段封锁协议要求未提交事务所写的任何数据在该事务提交之前均以排他方式加锁，防止其他事务读取这些数据。</p><p>强两阶段封锁协议更加严格：要求事务提交之前不得释放任何锁，在这个协议下，事务可以按其提交（commit）的顺序串行化。</p><h3 id="多粒度"><a href="#多粒度" class="headerlink" title="多粒度"></a>多粒度</h3><p>将多个数据项聚成一组，作为同步单元。这样对一组数据加锁。</p><p><strong>多粒度</strong>：允许各种大小的数据项，并定义数据粒度的层次结构，可以图形化表示为树。</p><p>如果一个事务对树的某个结点加了所，那么它也给统一模式下该结点的子结点隐式加锁。</p><p>锁的粒度:<br>细粒度 (树的低层): 高并发性，锁开销多<br>粗粒度 (树的高层): 低并发性，锁开销少</p><h4 id="意向锁类型"><a href="#意向锁类型" class="headerlink" title="意向锁类型"></a>意向锁类型</h4><p>除了排他锁和共享锁，多粒度下还有其他三种类型的锁：</p><ul><li>共享型意向锁（IS）：将树的较低层显式封锁，但只能施加共享锁</li><li>排他型意向锁（IX）：将树的较低层进行显式封锁，能施加S和X锁</li><li>共享排他型意向锁（SIX）：以该节点为根的子树显式加了共享锁，并且在树的更低层显式加了排他锁</li></ul><p>意向锁允许较高层的节点被加上共享锁或排他锁，而无需从树根遍历到子孙节点来检验锁的相容性，提升锁相容检验的效率。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2022/09/QQ%E6%88%AA%E5%9B%BE20230203162749-6.png"></p><p>事务Ti 按如下规则对数据项Q加锁：</p><ol><li>必须遵从锁类型相容函数</li><li>必须首先封锁树的根结点，并且可以加任意类型的锁</li><li>仅当事务Ti当前对Q的父结点具有IX或IS锁时，对结点Q可加S或IS锁</li><li>仅当事务Ti当前对Q的父结点具有IX时，对结点Q可加X、SIX或IX锁</li><li>仅当Ti未曾对任何结点解锁时，Ti可对结点加锁（满足两阶段封锁）</li><li>仅当Ti当前不持有Q的子结点的锁时，Ti可对结点Q解锁</li></ol><p>加锁按自顶向下的顺序，锁的释放按自底向上的顺序。</p><h4 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h4><p>对于系统中每个事务Ti，我们把一个唯一的固定时间戳和它联系起来，此时间戳记为TS(Ti)；该时间戳是在事务Ti开始执行前由数据库系统赋予的。</p><p>事务的时间戳决定了串行化顺序。</p><p>W-timestamp(Q)表示成功执行write(Q)的所有事务的最大时间戳。<br>R-timestamp(Q)表示成功执行read(Q)的所有事务的最大时间戳。</p><p>时间戳排序协议保证任何有冲突的rw操作按时间戳顺序执行。</p><p>对于指令read(Q)：</p><ul><li>若TS(Ti) &lt; W-timestamp(Q)，则Ti需要读入的Q值已被覆盖，read操作被拒绝，Ti回滚</li><li>若TS(Ti) &gt;&#x3D; W-timestamp(Q)，则执行read操作，R-timestamp(Q)更新为max(R-timestamp(Q), TS(Ti))</li></ul><p>对于指令write(Q)：</p><ul><li>若TS(Ti) &lt; R-timestamp(Q)，Q已经被读过了，Ti想要更新的值过时，write操作被拒绝，Ti回滚</li><li>若TS(Ti) &lt; W-timestamp(Q)，Q已经被写过了，write操作被拒绝，Ti回滚</li></ul><p>其他情况write操作正常执行。</p><p>时间戳排序协议保证冲突可串行化</p><ul><li>冲突操作按时间戳的顺序来处理</li></ul><p>保证无死锁</p><ul><li>不存在等待</li><li>可能有事务饿死</li></ul><p>可能产生不可恢复的调度</p><h4 id="基于有效性检查的协议"><a href="#基于有效性检查的协议" class="headerlink" title="基于有效性检查的协议"></a>基于有效性检查的协议</h4><p>有效性检查协议（适用于大部分只读事务的情况）要求每个事务Ti在其生命周期中按两个或三个阶段执行：</p><ul><li>读阶段：事务Ti的所有write操作都是对局部临时变量进行的</li><li>有效性检查阶段：事务Ti进行有效性测试，判断是否可以在不违反可串行性的基础上执行write操作</li><li>写阶段：如果Ti已通过有效性检查，则保存任何写操作结果的临时局部变量值被复制到数据库中。只读事务不进入此阶段。</li></ul><p>每个事务必须按照上述顺序经历这些阶段，然而，并发执行的事务的三个阶段可以是交叉执行的。</p><p>每个事务Ti都有三个不同的时间戳：</p><ul><li>Start(Ti)：事务Ti开始的时间</li><li>Validation(Ti)：事务Ti完成读阶段并开始其有效性检查的时间</li><li>Finish(Ti)：事务Ti完成写阶段的时间</li></ul><p>利用时间戳Validation(Ti)的值，通过时间戳排序技术决定可串行性顺序，以增加并发性。</p><p>对于任何满足TS (Tk) &lt; TS (Ti)的事务Tk必须满足下面两条件之一：</p><ul><li>Finish(Tk) &lt; Start(Ti)</li><li>Start(Ti) &lt; Finish(Tk) &lt; Validation(Ti) ，并且需保证Tk所写的数据项集与Ti所读数据项集不相交；即Tk的写操作不会影响到Ti的读操作。</li></ul><p>有效性检查协议能够自动预防级联回滚，保证无死锁。</p><h3 id="恢复系统"><a href="#恢复系统" class="headerlink" title="恢复系统"></a>恢复系统</h3><h4 id="故障分类"><a href="#故障分类" class="headerlink" title="故障分类"></a>故障分类</h4><p><strong>事务故障</strong>：</p><ul><li>逻辑错误：由于某些内部条件而无法继续正常执行</li><li>系统错误：系统进入一种不良状态，导致事务无法正常继续执行</li></ul><p><strong>系统崩溃</strong>：硬件故障，或者数据库软件、操作系统存在漏洞导致易失性存储器内容丢失，使得事务处理停止。</p><p><strong>磁盘故障</strong>：由于磁头损坏或故障造成磁盘块上的内容丢失。毁坏是可探测的：磁盘驱动器用校验和来检测故障。</p><h4 id="恢复机制"><a href="#恢复机制" class="headerlink" title="恢复机制"></a>恢复机制</h4><p>保证数据库一致性以及事务的原子性的算法称为恢复算法：</p><ul><li>在正常事务处理时采取措施，保证有足够的信息可用于故障恢复</li><li>故障发生后采取措施，将数据库内容恢复到某个保证数据库一致性、事务原子性及持久性的状态</li></ul><p>存储器类型：</p><ul><li>易失性存储器（volatile storage）：易失性存储器中信息在系统崩溃时通常无法保存下来。例子有主存和高速缓冲存储器</li><li>非易失性存储器（nonvolatile storage）：非易失性存储器中的信息在系统崩溃时可以保存下来。这类存储器的例子有磁盘和磁带（但仍有可能丢失数据）</li><li>稳定存储器（stable storage）：稳定存储器中的信息永不丢失</li></ul><p>事务</p><ul><li>必须在第一次访问X之前执行read(X)</li><li>write(X)可以在事务被提交前的任意时刻执行</li></ul><p>为保证原子性，我们必须在修改数据库本身之前，首先向稳定<br>存储器输出信息，描述要做的修改<br>目的：确保由中止事务所做的修改不会持久保存于数据库中，即回滚该中止事务</p><h4 id="基于日志的恢复机制"><a href="#基于日志的恢复机制" class="headerlink" title="基于日志的恢复机制"></a>基于日志的恢复机制</h4><p>日志保存于稳定存储器中，日志是日志记录的序列。它记录数据库中的所有更新活动。</p><p>立即修改模式允许在事务提交前，将未提交的事务更新至缓冲<br>区或磁盘</p><p>延迟修改模式直到事务提交时都没有更新到缓冲区&#x2F;磁盘</p><ul><li>简化了恢复</li><li>但是多了存储本地副本的开销</li></ul><p>日志记录的更新必须在数据项被write（数据库修改）之前完<br>成。假设日志记录直接被写入稳定存储器</p><p>当事务将其关于提交的日志记录输出到稳定存储器时，该事务<br>被认为已提交。之前的所有日志记录必须都已经输出</p><p>事务提交时，由该事务执行的write操作结果可能仍在缓冲区，随后被输出</p><p>在并发事务中，所有事务共享一个磁盘缓冲区和日志</p><p>从故障中恢复时:<br>当日志是以下状态时，事务Ti需要进行undo操作<br>• 有日志 Ti, start<br>• 没有日志Ti, commit和Ti, abort<br>当日志是以下状态时，事务Ti需要进行redo操作<br>• 有日志 Ti, start<br>• 有日志Ti, commit或Ti, abort</p><p>囧：如果事务Ti 之前执行了undo操作，Ti abort被写入到日志，接着故障发生。为了从故障中恢复，Ti 要执行redo操作</p><p>这样的redo操作重新执行了原先的所有操作，包括重新存储旧值<br>• 称为重复历史<br>• 看起来很浪费，但是最大程度地简化了恢复</p><h5 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h5><p>流线型恢复过程周期性地执行检查点</p><ol><li>将当前位于主存的所有日志记录输出到稳定存储器上</li><li>将所有修改了的缓冲块输出到磁盘上</li><li>将一个日志记录&lt; checkpoint L&gt;输出到稳定存储器</li></ol><p>执行检查点时，所有数据更新都停止</p><p>只有在L未提交&#x2F;中止的事务或者在检查点后开始的事务需要redo或undo</p><h2 id="第十五章-大数据与分布式数据库系统"><a href="#第十五章-大数据与分布式数据库系统" class="headerlink" title="第十五章 大数据与分布式数据库系统"></a>第十五章 大数据与分布式数据库系统</h2><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><p>大数据是大容量（Volume）、高流速（Velocity）、多样化（Variety）、高价值、真实的信息资产，它需要新的数据处理形式来增强决策、提升洞察力、优化处理过程。<br>5V特性：</p><ul><li>Variety</li><li>Velocity</li><li>Volume</li><li>Value（高价值）</li><li>Veracity (真实性)</li></ul><h3 id="并行数据库架构"><a href="#并行数据库架构" class="headerlink" title="并行数据库架构"></a>并行数据库架构</h3><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>处理器（或处理器内核）和磁盘可以访问公共内存。<br>优点是进程间高效通信，缺点是无法扩展到超过64-128个处理器内核。</p><p>共享内存系统可以有多个处理器，每个处理器都有自己的缓存级别。</p><h4 id="共享磁盘"><a href="#共享磁盘" class="headerlink" title="共享磁盘"></a>共享磁盘</h4><p>所有处理器都可以通过互连网络直接访问所有磁盘，但处理器具有私有内存存储器。<br>缺点：瓶颈现在出现在与磁盘子系统的互连网络。</p><h4 id="无共享架构"><a href="#无共享架构" class="headerlink" title="无共享架构"></a>无共享架构</h4><p>节点由处理器、内存和一个或多个磁盘组成；通过互连网络进行所有通信，可以无干扰地扩展到数千个处理器。<br>缺点：通信成本和非本地磁盘访问；发送数据涉及两端的软件交互。</p><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>结合共享内存、共享磁盘和无共享架构的特征</p><p>顶层是无共享架构<br>• 系统的每个节点都是共享内存系统<br>或者，顶层可以是共享磁盘系统<br>• 系统的每个节点都是共享内存系统</p><p>共享内存在内部看起来像无共享！</p><ul><li>每个处理器都可以直接访问自己的内存，间接（硬件级别）访问其余内存</li><li>也称为非统一内存架构 (NUMA)</li></ul><p>无共享——可以看起来像共享内存</p><ul><li>通过分布式虚拟内存抽象来降低此类系统编程的复杂性</li><li>远程直接内存访问 (RDMA) 在无共享系统上提供非常低延迟的共享内存抽象。由于其非常低的延迟，通常在无限带宽（infiniband） 之上实施。但是粗心的编程会导致性能问题</li></ul><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><p>数据分布在多台机器上。</p><p>分布式数据库：</p><ul><li>同构分布式数据库：所有站点上的相同软件&#x2F;架构、数据可能分布于站点之间，提供单个数据库的视图（全局模式），隐藏分布细节</li><li>异构分布式数据库：不同站点上的不同软件&#x2F;架构，整合现有数据库以提供有用的功能</li></ul><p>区分本地事务和全局事务</p><ul><li>本地事务访问启动事务的单个站点中的数据</li><li>全局事务要么访问与启动事务的站点不同的站点中的数据，要么访问多个不同站点中的数据</li></ul><p>数据集成的好处：</p><ul><li>共享数据——一个站点的用户能够访问其他站点的数据</li><li>自治——每个站点都能够对本地存储的数据保持一定程度的控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计科专业课笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《编译原理》笔记</title>
      <link href="/2023/07/03/%E3%80%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/03/%E3%80%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%AE%BA">第一章 引论</a><ul><li><a href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F">编译程序</a></li><li><a href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">编译过程</a></li><li><a href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">编译程序结构</a><ul><li><a href="#%E8%A1%A8%E6%A0%BC%E4%B8%8E%E8%A1%A8%E6%A0%BC%E7%AE%A1%E7%90%86">表格与表格管理</a></li><li><a href="#%E5%87%BA%E9%94%99%E5%A4%84%E7%90%86">出错处理</a></li><li><a href="#%E9%81%8Dpass">遍pass</a></li><li><a href="#%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF">编译前端与后端</a></li></ul></li><li><a href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%88%90">编译程序生成</a></li></ul></li><li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0">第二章 高级语言及其语法描述</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9A%E4%B9%89">程序语言的定义</a><ul><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li><li><a href="#%E8%AF%AD%E4%B9%89">语义</a></li></ul></li><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">程序语言的基本功能和层次结构</a></li><li><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E8%88%AC%E7%89%B9%E6%80%A7">高级语言的一般特性</a><ul><li><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB">高级语言的分类</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84">程序结构</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%93%8D%E4%BD%9C">数据类型与操作</a></li><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%90%8D%E5%AD%97">标识符与名字</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">抽象数据类型</a></li></ul></li><li><a href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">语句与控制结构</a><ul><li><a href="#%E8%AF%AD%E5%8F%A5">语句</a></li></ul></li><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0">程序语言的语法描述</a><ul><li><a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95">上下文无关文法</a></li><li><a href="#%E8%AF%AD%E6%B3%95%E6%A0%91%E4%B8%8E%E4%BA%8C%E4%B9%89%E6%80%A7">语法树与二义性</a></li><li><a href="#%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E9%B8%9F%E7%9E%B0">形式语言鸟瞰</a><ul><li><a href="#0%E5%9E%8B%E6%96%87%E6%B3%95">0型文法</a></li><li><a href="#1%E5%9E%8B%E6%96%87%E6%B3%95">1型文法</a></li><li><a href="#2%E5%9E%8B%E6%96%87%E6%B3%95">2型文法</a></li><li><a href="#3%E5%9E%8B%E6%96%87%E6%B3%95">3型文法</a></li></ul></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">第三章 词法分析</a><ul><li><a href="#%E5%AF%B9%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82">对词法分析器的要求</a><ul><li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E8%BE%93%E5%87%BA%E5%BD%A2%E5%BC%8F">词法分析器的功能和输出形式</a></li><li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F">词法分析器作为一个独立的子程序</a></li></ul></li><li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1">词法分析器的设计</a><ul><li><a href="#%E8%BE%93%E5%85%A5%E9%A2%84%E5%A4%84%E7%90%86">输入、预处理</a></li><li><a href="#%E5%8D%95%E8%AF%8D%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%AF%86%E5%88%AB%E8%B6%85%E5%89%8D%E6%90%9C%E7%B4%A2">单词符号的识别：超前搜索</a></li><li><a href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE">状态转换图</a></li></ul></li><li><a href="#%E6%AD%A3%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA">正规表达式与有限自动机</a><ul><li><a href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E5%92%8C%E6%AD%A3%E8%A7%84%E9%9B%86">正规式和正规集</a></li><li><a href="#%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BAdfa">确定有限自动机DFA</a></li><li><a href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BAnfa">非确定有限自动机NFA</a></li><li><a href="#nfa%E7%A1%AE%E5%AE%9A%E5%8C%96">NFA确定化</a></li><li><a href="#%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E4%B8%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AD%89%E4%BB%B7%E6%80%A7">正规文法与有限自动机等价性</a></li><li><a href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E4%B8%8E%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AD%89%E4%BB%B7%E6%80%A7">正规式与有限自动机等价性</a></li><li><a href="#dfa%E6%9C%80%E5%B0%8F%E5%8C%96">DFA最小化</a></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90">第四章 语法分析——自上而下分析</a><ul><li><a href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89">上下文无关文法的定义</a></li><li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95">语法分析的方法</a><ul><li><a href="#%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98">自上而下分析面临的问题</a></li></ul></li><li><a href="#ll1%E5%88%86%E6%9E%90%E6%B3%95">LL(1)分析法</a><ul><li><a href="#%E5%B7%A6%E9%80%92%E5%BD%92%E7%9A%84%E6%B6%88%E9%99%A4">左递归的消除</a></li><li><a href="#%E6%B6%88%E9%99%A4%E5%9B%9E%E6%BA%AF%E6%8F%90%E5%B7%A6%E5%9B%A0%E5%AD%90">消除回溯，提左因子</a></li><li><a href="#firstfollow%E9%9B%86%E5%90%88">FIRST、FOLLOW集合</a></li></ul></li><li><a href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E6%9E%84%E9%80%A0">递归下降分析程序构造</a></li><li><a href="#%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F">预测分析程序</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%88%86%E6%9E%90%E8%A1%A8">构造分析表</a></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90">第五章 语法分析——自下而上分析</a><ul><li><a href="#%E5%BD%92%E7%BA%A6">归约</a><ul><li><a href="#%E8%A7%84%E8%8C%83%E8%A7%84%E7%BA%A6">规范规约</a></li></ul></li><li><a href="#lr%E5%88%86%E6%9E%90%E6%B3%95">LR分析法</a><ul><li><a href="#lr%E5%88%86%E6%9E%90%E5%99%A8">LR分析器</a></li><li><a href="#lr0%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%97%8F%E5%92%8C%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0">LR(0)项目集族和分析表构造</a></li><li><a href="#slr%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0">SLR分析表构造</a></li><li><a href="#lr1%E5%88%86%E6%9E%90%E8%A1%A8%E6%9E%84%E9%80%A0">LR(1)分析表构造</a></li><li><a href="#lalr1%E6%9E%84%E9%80%A0">LALR(1)构造</a></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91">第六章 属性文法和语法制导翻译</a><ul><li><a href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95">属性文法</a><ul><li><a href="#%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7">综合属性</a></li><li><a href="#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7">继承属性</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">基于属性文法的处理方法</a><ul><li><a href="#%E4%BE%9D%E8%B5%96%E5%9B%BE">依赖图</a></li><li><a href="#%E6%A0%91%E9%81%8D%E5%8E%86">树遍历</a></li><li><a href="#%E4%B8%80%E9%81%8D%E6%89%AB%E6%8F%8F">一遍扫描</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91">抽象语法树</a></li></ul></li><li><a href="#s-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E8%AE%A1%E7%AE%97">S-属性文法的自下而上计算</a></li><li><a href="#l-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BF%BB%E8%AF%91">L-属性文法和自顶向下翻译</a><ul><li><a href="#%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F">翻译模式</a></li><li><a href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%BF%BB%E8%AF%91">自顶向下翻译</a></li><li><a href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%BF%BB%E8%AF%91%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1">递归下降翻译器的设计</a></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%BA%A7%E7%94%9F">第七章 语义分析和中间代码产生</a><ul><li><a href="#%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80">中间语言</a><ul><li><a href="#%E5%90%8E%E7%BC%80%E5%BC%8F">后缀式</a></li><li><a href="#%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95">图表示法</a></li><li><a href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81">三地址代码</a><ul><li><a href="#%E5%9B%9B%E5%85%83%E5%BC%8F">四元式</a></li><li><a href="#%E4%B8%89%E5%85%83%E5%BC%8F">三元式</a></li><li><a href="#%E9%97%B4%E6%8E%A5%E4%B8%89%E5%85%83%E5%BC%8F">间接三元式</a></li></ul></li></ul></li><li><a href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91">赋值语句的翻译</a><ul><li><a href="#%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">简单算术表达式及赋值语句</a></li><li><a href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%BC%95%E7%94%A8">数组元素的引用</a></li></ul></li><li><a href="#%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91">布尔表达式的翻译</a></li></ul></li><li><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%BB%84%E7%BB%87">第九章 运行时存储空间组织</a><ul><li><a href="#%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%B4%BB%E5%8A%A8">目标程序运行时的活动</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a><ul><li><a href="#%E4%BC%A0%E5%9C%B0%E5%9D%80-call-by-reference">传地址 Call by reference</a></li><li><a href="#%E5%BE%97%E7%BB%93%E6%9E%9C-call-by-result">得结果 Call by result</a></li><li><a href="#%E4%BC%A0%E5%80%BC-call-by-value">传值 Call by value</a></li><li><a href="#%E4%BC%A0%E5%90%8D-call-by-name">传名 Call by name</a></li></ul></li></ul></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%92%E5%88%86">运行时存储器的划分</a><ul><li><a href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">活动记录</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">存储分配策略</a></li></ul></li><li><a href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86">静态存储管理</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A0%88%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D">一个简单栈式存储分配</a><ul><li><a href="#c%E7%9A%84%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">C的活动记录</a></li><li><a href="#c%E7%9A%84%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E8%BF%9B%E5%85%A5%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%92%8C%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E">C的过程调用、过程进入、数组空间分配和过程返回</a></li></ul></li><li><a href="#%E5%B5%8C%E5%A5%97%E8%BF%87%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%88%E5%BC%8F%E5%AE%9E%E7%8E%B0">嵌套过程语言的栈式实现</a><ul><li><a href="#%E9%9D%9E%E5%B1%80%E9%83%A8%E5%90%8D%E5%AD%97%E7%9A%84%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%9E%E7%8E%B0">非局部名字的访问的实现</a><ul><li><a href="#%E9%9D%99%E6%80%81%E9%93%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95">静态链和活动记录</a></li><li><a href="#%E5%B5%8C%E5%A5%97%E5%B1%82%E6%AC%A1%E6%98%BE%E7%A4%BA%E8%A1%A8display">嵌套层次显示表display</a></li><li><a href="#pl%E5%85%A8%E5%B1%80display%E8%A1%A8">PL全局display表</a></li></ul></li></ul></li></ul></li><li><a href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E4%BC%98%E5%8C%96">第十章 优化</a><ul><li><a href="#%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96">局部优化</a><ul><li><a href="#%E5%88%92%E5%88%86%E5%9F%BA%E6%9C%AC%E5%9D%97">划分基本块</a></li><li><a href="#%E6%B5%81%E5%9B%BE">流图</a></li></ul></li></ul></li></ul><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><h3 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h3><p><strong>翻译程序</strong>：把某一种语言程序等价地转换成另一种语言程序的程序。<br><strong>编译程序</strong>：把<strong>高级</strong>语言程序等价地转换成另一种<strong>低级</strong>语言程序的程序。<br><strong>解释程序</strong>：把源语言写的源程序作为输入，但<strong>不产生目标程序</strong>，而是<strong>边解释边执行</strong>源程序本身。</p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>编译过程一般经过下列五个步骤：</p><ul><li>词法分析，识别出句子中的单词</li><li>语法分析，分析句子的语法结构</li><li>中间代码产生，根据句子的含义进行初步翻译</li><li>优化，对译文进行修饰</li><li>目标代码产生，写出最后的译文</li></ul><p><strong>词法分析</strong>：</p><ul><li>任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个单次符号</li><li>原则：构词规则（保留字、标识符、常数等）</li><li>描述工具：有限自动机</li></ul><p><strong>语法分析</strong>：</p><ul><li>任务：在词法分析的基础上，根据语言的语法规则把单词符号串分解成各类语法单位</li><li>原则：语法规则</li><li>描述工具：上下文无关文法</li></ul><p><strong>中间代码产生</strong>：</p><ul><li>任务：对各类不同语法范畴按语言的语义进行初步翻译</li><li>原则：语义规则</li><li>中间代码：三元式、四元式、树形结构等<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230308105052.png"></li></ul><p><strong>优化</strong>：</p><ul><li>任务：对于前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码</li><li>原则：程序的等价变换</li></ul><p><strong>目标代码产生</strong>：</p><ul><li>任务：把中间代码变换成特定机器上的目标代码</li><li>依赖于硬件系统结构和机器指令的含义</li><li>目标代码有三种形式：</li><li><ul><li>绝对指令代码: 可直接运行</li></ul></li><li><ul><li>可重新定位指令代码: 需要连接装配</li></ul></li><li><ul><li>汇编指令代码: 需要进行汇编</li></ul></li></ul><h3 id="编译程序结构"><a href="#编译程序结构" class="headerlink" title="编译程序结构"></a>编译程序结构</h3><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230308105052-1.png"></p><h4 id="表格与表格管理"><a href="#表格与表格管理" class="headerlink" title="表格与表格管理"></a>表格与表格管理</h4><p>编译程序在工作过程中需要保持一系列的表格，以登记源程序的各类信息和编译各阶段的进展状况。<br><strong>符号表</strong>：等级源程序中出现的每个名字以及名字的各种属性。<br>表格还有：常数表、入口名表、标号表和标号对应的代码形式表。</p><h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p><strong>出错处理程序</strong>：发现源程序中的错误，把有关错误信息（语法错误、语义错误）报告给用户。</p><h4 id="遍pass"><a href="#遍pass" class="headerlink" title="遍pass"></a>遍pass</h4><p>所谓”遍”， 就是对源程序或源程序的中间表示从头到尾扫描一次。<br>阶段与遍是不同的概念。一遍可以由若干段组成，一个阶段也可以分若干遍来完成。</p><h4 id="编译前端与后端"><a href="#编译前端与后端" class="headerlink" title="编译前端与后端"></a>编译前端与后端</h4><p><strong>编译前端</strong>：与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化。<br><strong>编译后端</strong>：与目标机有关，与目标机有关的优化，目标代码产生。</p><p>优点：减少对内存容量的要求，程序逻辑结构清晰; 优化更充分，有利于移植。<br>不足: 编译程序运行的效率低</p><h3 id="编译程序生成"><a href="#编译程序生成" class="headerlink" title="编译程序生成"></a>编译程序生成</h3><p><strong>以汇编语言和机器语言为工具</strong><br>优点: 可以针对具体的机器，充分发挥计算机的系统功能。生成的程序效率高。<br>缺点: 程序难读、难写、易出错、难维护、生产的效率低。</p><p><strong>高级语言书写</strong><br>利用已有的某种语言的编译程序实现另一语言的编译程序。<br>优点: 程序易读、易理解、容易维护、生产的效率高。<br>缺点: 难以充分发挥计算机的系统功能，生成的程序效率低。</p><p><strong>自展技术</strong>：首先确定一个非常简单的核心语言 L1，用机器语言或汇编语言写出它的编译程序 T1，再把 L1 扩充到 L1+L2，并用 L1编写它的编译程序 T2，……，直到获得要求的编译程序。这种通过一系列自展途径形成编译程序的过程叫自编译过程。</p><h2 id="第二章-高级语言及其语法描述"><a href="#第二章-高级语言及其语法描述" class="headerlink" title="第二章 高级语言及其语法描述"></a>第二章 高级语言及其语法描述</h2><h3 id="程序语言的定义"><a href="#程序语言的定义" class="headerlink" title="程序语言的定义"></a>程序语言的定义</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><strong>语法</strong>：一组规则，用它可以形成和产生一 个合式(well-formed)的程序。</p><p><strong>词法规则</strong>：单词符号的形成规则。描述工具是有限自动机。</p><p><strong>语法规则</strong>：语法单位的形成规则。描述工具是上下文无关文法。</p><p>语法规则和词法规则定义了程序的的形式结构。</p><h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><p><strong>语义</strong>：一组规则，用它可以定义一个程序的意义。</p><p><strong>描述方法</strong>：</p><ul><li>自然语言描述：可能存在隐藏错误、二义性和不完整性</li><li>形式描述</li></ul><h3 id="程序语言的基本功能和层次结构"><a href="#程序语言的基本功能和层次结构" class="headerlink" title="程序语言的基本功能和层次结构"></a>程序语言的基本功能和层次结构</h3><p>程序语言的基本功能是描述数据和对数据的运算。</p><p>程序：</p><ul><li>子程序或分程序</li><li><ul><li>语句</li><li><ul><li>表达式</li><li><ul><li>数据引用</li><li>算符</li><li>函数调用</li></ul></li></ul></li></ul></li></ul><h3 id="高级语言的一般特性"><a href="#高级语言的一般特性" class="headerlink" title="高级语言的一般特性"></a>高级语言的一般特性</h3><h4 id="高级语言的分类"><a href="#高级语言的分类" class="headerlink" title="高级语言的分类"></a>高级语言的分类</h4><p><strong>强制式语言</strong>：也称过程式语言，命令驱动，面向语句。</p><p><strong>应用式语言</strong>：注重程序所表示的功能，而不是一个语句接一个语句地执行。</p><p><strong>基于规则的语言</strong>：检查一定的条件，当它满足值，则执行适当的动作。</p><p><strong>面向对象语言</strong>：封装性、继承性和多态性。</p><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><p><strong>FORTRAN</strong>：</p><ul><li>一个FORTRAN程序由一个主程序段和若干个辅程序段组成</li><li>辅程序段可以是子程序、函数段或数据块</li><li>每个程序段有一系列的说明语句和执行语句组成，各段可以独立编译</li><li>模块结构，没有嵌套和递归</li><li>各程序段中的名字相互独立，同一个标识符在不同程序段中代表不同的名字</li></ul><p><strong>PASCAL</strong>：</p><ul><li><p>PASCAL程序本身可以看成是一个操作系统所调用的过程，过程可以嵌套和递归</p></li><li><p>作用域：一个名字能被使用的区域范围称作这个名字的作用域</p></li><li><p>允许用同一个标识符在不同的过程中代表不同的名字</p></li><li><p><strong>最近嵌套原则</strong>：一个在子程序B1中说明的名字X只在B1中有效（局部于B1）如果B2是B1的一个内层子程序且B2中对标识符X没有新的说明，则原来的名字X在B2中仍然有效。如果B2对X重新作了说明， 那么，B2对X的任何引用都是指重新说明过的这个X</p></li><li><p>PASCAL提供了丰富的数据类型和运算方式，它允许用户动态地申请和退还存贮空间</p></li></ul><p><strong>ADA</strong>：</p><ul><li>程序包：把数据和操作代码封装在一起，支持数据抽象</li><li>一个程序包分为两部分：</li><li><ul><li>可见的规范说明部分，它定义了程序包外面可以访问的对象</li><li>程序包体，它实际定义程序包的实现细节</li></ul></li></ul><p><strong>JAVA</strong>：</p><ul><li>一种面向对象的高级语言</li></ul><h4 id="数据类型与操作"><a href="#数据类型与操作" class="headerlink" title="数据类型与操作"></a>数据类型与操作</h4><p>一个数据类型通常包括以下三种要素：</p><ul><li>用于区别这种类型数据对象的属性</li><li>这种类型的数据对象可以具有的值</li><li>可以作用于这种类型的数据对象的操作</li></ul><h4 id="标识符与名字"><a href="#标识符与名字" class="headerlink" title="标识符与名字"></a>标识符与名字</h4><p><strong>标识符</strong>：以字母开头的，由字母数字组成的字符串。</p><p>标识符与名字的区别在于：</p><ul><li>标识符是语法概念</li><li>名字有确切的意义和属性</li></ul><p>一个名字的属性包括<strong>类型</strong>和<strong>作用域</strong>。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>数组</strong>：</p><ul><li>逻辑上，数组是由同一类型数据所组成的某种n维矩形结构，沿着每一维的距离称为下标</li></ul><p><strong>内情向量</strong>：把数组的有关信息记录在一个“内情向量”中，每个数组的内情向量必须包括：维数，各维的上、下限，首地址，以及数组（元素）的类型。</p><p><strong>记录</strong></p><p>逻辑上说，记录结构由已知类型的数据组合在一起的一种结构。</p><p>域的地址计算：相对于记录结构起点的相对数OFFSET。</p><p><strong>字符串、表格、栈</strong></p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>一个抽象数据类型包括：</p><ul><li>数据对象的一个集合</li><li>作用于这些数据对象的抽象运算的集合</li><li>这种类型对象的封装，用户只能使用类型定义的运算</li></ul><h3 id="语句与控制结构"><a href="#语句与控制结构" class="headerlink" title="语句与控制结构"></a>语句与控制结构</h3><p>表达式由运算量和算符组成。</p><p>对于多数程序语言来说，表达式的形成规则可概括为：</p><ul><li>变量、常数是表达式</li><li>若E1、E2为表达式，<code>$$\theta$$</code>是一个二元算符，则<code>$$E1\theta E2$$</code>是表达式</li><li>若E是表达式，<code>$$\theta$$</code>是一个一元算符，则<code>$$\theta E$$</code>是表达式</li><li>若E是表达式，则(E)是表达式</li></ul><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p><strong>赋值语句</strong>：A :&#x3D; B</p><p>名字左值：该名字代表的那个单元称为该名字的左值。</p><p>右值：一个名字的值称为该名字的右值。</p><p><strong>控制语句</strong></p><p><strong>说明句</strong>：旨在定义名字的性质。定义各种不同数据类型的变量或运算。</p><p><strong>简单句和复合句</strong></p><h3 id="程序语言的语法描述"><a href="#程序语言的语法描述" class="headerlink" title="程序语言的语法描述"></a>程序语言的语法描述</h3><h4 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h4><p><strong>文法</strong>：描述语言的语法结构的形式规则</p><p>一个上下文无关文法G是一个四元式<br><code>$$G=(V_T,V_N,S,P)$$</code><br>其中四个符号分别代表：</p><ul><li>终结符集合：是一个语言的不可再分的基本符号</li><li>非终结符集合：代表一个一定的语法概念</li><li>文法的开始符号：特殊的非终结符号</li><li>产生式集合：定义语法范畴的一种书写规则，如下述举例：</li><li><ul><li>E→i对应a</li><li>E→E+E对应a+b</li><li>E→E*E对应a*b</li><li>E→(E)对应(a)</li></ul></li></ul><p>表示一个文法时，通常只给出开始符号和产生式。</p><p><strong>推出</strong>：称<code>$$aAb$$</code>直接推出<code>$$a\gamma b$$</code>，仅当<code>$$A\rightarrow \gamma$$</code>是一个产生式，且<code>$$a,b\in (V_T\cup V_N)^*$$</code></p><p>假定G是一个文法，S是它的开始符号。如果S经过0步或若干步可以推出a，则称<strong>a是一个句型</strong>。<strong>仅含终结符号的句型是一个句子</strong>。**文法G所产生的句子的全体是一个语言，记为L(G)**。</p><p><strong>最左推导</strong>：任何一步推导都是对a的最左非终结符进行替换。<br><strong>最右推导</strong>：任何一步推导都是对a的最右非终结符进行替换。也称规范推导。</p><h4 id="语法树与二义性"><a href="#语法树与二义性" class="headerlink" title="语法树与二义性"></a>语法树与二义性</h4><p>用一张图表示一个句型的推导，称为语法树。<br>若一个文法中存在某个句子，它有两个不同的最左（右）推导，那么这个文法是<strong>二义</strong>的。<br>若对于一个语言，不存在无二义性的文法，则这个语言是二义的。</p><p>文法的二义性和语言的二义性是两个不同的概念。可能存在两个不同的文法，一个是二义的而另一个不是二义的，但是它们产生的语言是相同的。</p><p>描述程序设计语言时，对于上下文无关文法的限制：</p><ul><li>不含P→P形式的产生式</li><li>每个非终结符P必须有用处</li></ul><h4 id="形式语言鸟瞰"><a href="#形式语言鸟瞰" class="headerlink" title="形式语言鸟瞰"></a>形式语言鸟瞰</h4><p>Chomsky于1956年建立形式语言体系，他把文法分成四种类型：0，1，2，3型。</p><h5 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h5><p>短语文法，图灵机<br>产生式形如：<code>$$a\rightarrow \beta$$</code><br>其中：<code>$$a\in (V_T \cup V_n)^*$$</code>至少含有一个非终结符；<code>$$\beta \in (V_T \cup V_N)^*$$</code>。</p><h5 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h5><p>上下文有关文法，线性界限自动机<br>产生式形如：<code>$$a\rightarrow \beta$$</code><br>其中<code>$$|a| \leq |\beta|$$</code>，仅<code>$$S\rightarrow \epsilon$$</code>例外。</p><h5 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h5><p>上下文无关文法，非确定下推自动机<br>产生式形如：<code>$$A\rightarrow \beta$$</code><br>其中：<code>$$A\in V_N; \beta \in (V_T \cup V_n)^*$$</code>。</p><h5 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h5><p>正规文法，有限自动机<br>产生式形如：<code>$$A\rightarrow aB | A\rightarrow a$$</code><br>其中：<code>$$a\in V_T^*; A,B\in V_N$$</code>。右线性文法。</p><h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><h3 id="对词法分析器的要求"><a href="#对词法分析器的要求" class="headerlink" title="对词法分析器的要求"></a>对词法分析器的要求</h3><h4 id="词法分析器的功能和输出形式"><a href="#词法分析器的功能和输出形式" class="headerlink" title="词法分析器的功能和输出形式"></a>词法分析器的功能和输出形式</h4><p><strong>功能</strong>：输入源程序、输出单词符号。<br><strong>单词符号的种类</strong>：</p><ul><li>基本字：如begin，repeat</li><li>标识符：如变量名、数组名、过程名</li><li>常数</li><li>运算符</li><li>界符：逗号，分号，括号，空格</li></ul><p><strong>输出单次符号的表示形式</strong>：（单词种别，值）<br>单词种别通常用整数编码表示。<br>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字、运算符和界符都是一符一种。<br>若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。<br>标识符单列一种；标识符自身的值表示成按机器字节划分的内部码。<br>常数按类型分种；常数的值则表示成标准的二进制形式。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i&gt;=j) i--;</span><br></pre></td></tr></table></figure><p>输出单词符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;while, -&gt;</span><br><span class="line">&lt;(, -&gt;</span><br><span class="line">&lt;id, 指向i符号表项的指针&gt;</span><br><span class="line">&lt;&gt;=, -&gt;</span><br><span class="line">&lt;id, 指向j的符号表项的指针&gt;</span><br><span class="line">&lt;), -&gt;</span><br><span class="line">&lt;id, 指向i的符号表项的指针&gt;</span><br><span class="line">&lt;--, -&gt;</span><br><span class="line">&lt;;, -&gt;</span><br></pre></td></tr></table></figure><h4 id="词法分析器作为一个独立的子程序"><a href="#词法分析器作为一个独立的子程序" class="headerlink" title="词法分析器作为一个独立的子程序"></a>词法分析器作为一个独立的子程序</h4><p>作为独立阶段的优点：结构简洁、清晰和条理化，有利于集中考虑词法分析一些枝节问题。<br>不作为一遍：将其处理为一个子程序。</p><h3 id="词法分析器的设计"><a href="#词法分析器的设计" class="headerlink" title="词法分析器的设计"></a>词法分析器的设计</h3><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230412104429.png"></p><h4 id="输入、预处理"><a href="#输入、预处理" class="headerlink" title="输入、预处理"></a>输入、预处理</h4><p>输入串放在输入缓冲区中。<br>预处理子程序：剔除无用的空白、跳格、回车等编辑性字符；区分标号区、捻接续行和给出句末符等。</p><p><strong>扫描缓冲区</strong>：<br>一个指示token起点，一个搜索token终点。可将字串先放入一个半区，搜到边缘仍未结束则将后续字串放入另一个半区。<br>标识符和常数的长度必须受限，小于缓冲区半区长度。</p><h4 id="单词符号的识别：超前搜索"><a href="#单词符号的识别：超前搜索" class="headerlink" title="单词符号的识别：超前搜索"></a>单词符号的识别：超前搜索</h4><p>对于关键字的识别，如果不存在关键字特殊保护，那么就需要超前搜索后续字符，来区分关键字和用户定义标识符。</p><p>对于常数识别，有些也需要超前搜索。</p><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p>转换图是一张有限方向图。在状态转换图中，结点代表状态，用圆圈表示。状态之间用箭头连接。箭头标记代表在射出节点状态下可能出现的输入字符或字符类。</p><p>若：</p><ul><li>所有基本字都是保留字;用户不能用它们作自己的标识符；</li><li>基本字作为特殊的标识符来处理;不用特殊的状态图来识别，只要查保留字表；</li><li>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔，<br>则不必使用超前搜索。</li></ul><p>将每个状态节点对应一小段程序，可以实现状态转换图：</p><ul><li>对不含回路的分叉结点，可以用一个CASE语句或者一组IF-ELSE实现</li><li>对含回路的状态结，可对应一段由WHILE结构和IF语句构成的程序</li><li>终态结点表示识别出某种单词符号，对应语句为RETURN</li></ul><h3 id="正规表达式与有限自动机"><a href="#正规表达式与有限自动机" class="headerlink" title="正规表达式与有限自动机"></a>正规表达式与有限自动机</h3><h4 id="正规式和正规集"><a href="#正规式和正规集" class="headerlink" title="正规式和正规集"></a>正规式和正规集</h4><p>正规集可以用正规式表示。一个由字构成的集合是正规集，当且仅当它能用正规式表示。</p><p>递归定义：<br>对于给定的字母表<code>$$\sum $$</code></p><ul><li><code>$$\epsilon$$</code>和<code>$$\emptyset$$</code>都是<code>$$\sum $$</code>上的正规式，它们所表示的正规集为<code>$$\&#123;\epsilon\&#125;, \emptyset$$</code></li><li>任何<code>$$a \in \sum$$</code>，<code>$$a$$</code>是<code>$$\sum $$</code>上的正规式，它所表示的正规集为<code>$$\&#123;a\&#125;$$</code></li><li>假定<code>$$e_1,e_2$$</code>都是<code>$$\sum$$</code>上的正规式，它们所表示的正规集为<code>$$L(e_1), L(e_2)$$</code>，则</li><li><ul><li><code>$$(e_1|e_2)$$</code>为正规式，它所表示的正规集为<code>$$L(e_1) \cup L(e_2)$$</code></li></ul></li><li><ul><li><code>$$(e_1·e_2)$$</code>为正规式，它所表示的正规集为<code>$$L(e_1)L(e_2)$$</code></li></ul></li><li><ul><li><code>$$(e_1)^*$$</code>为正规式，它所表示的正规集为<code>$$(L(e_1))^*$$</code><br>仅由有限次使用上述三步骤定义的表达式才是<code>$$\sum$$</code>上的正规式，仅由这些正规式表示的子集才是<code>$$\sum$$</code>上的正规集。</li></ul></li></ul><h4 id="确定有限自动机DFA"><a href="#确定有限自动机DFA" class="headerlink" title="确定有限自动机DFA"></a>确定有限自动机DFA</h4><p>自动机M是一个五元式<code>$$M=(S,\sum,f,S_0,F)$$</code>，其中项依次为：</p><ul><li>有穷状态集</li><li>输入字母表</li><li>状态转换函数</li><li>S的唯一初态</li><li>终态集</li></ul><h4 id="非确定有限自动机NFA"><a href="#非确定有限自动机NFA" class="headerlink" title="非确定有限自动机NFA"></a>非确定有限自动机NFA</h4><p>一个NFA是一个五元式<code>$$M=(S,\sum,f,S_0,F)$$</code>，其中项以此为：</p><ul><li>有穷状态集</li><li>输入字母表</li><li>状态转换函数</li><li>非空的初态集</li><li>终态集</li></ul><p>DFA是NFA的特例。</p><p>对于任何两个有限自动机M和M’，如果<code>$$L(M) = L(M&#39;)$$</code>则二者等价。</p><h4 id="NFA确定化"><a href="#NFA确定化" class="headerlink" title="NFA确定化"></a>NFA确定化</h4><p>对于每个NFA存在一个DFA，二者等价。</p><p>对于一个NFA，进行如下改造：</p><ul><li>引进新初态终态X和Y，其不属于S。将X到<code>$$S_0$$</code>中任意状态连一条<code>$$\epsilon$$</code>弧，从F中任意状态连一条<code>$$\epsilon$$</code>弧到Y</li><li>按照下面三条规则分裂所有弧</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610.png"></p><p>采用子集法确定化上述NFA。</p><ul><li>将初态X及其经过任意条<code>$$\epsilon$$</code>弧能到达的状态放入初始集合中</li><li>对于在字符表中的所有字符，写出其从初始集合的任意状态经过1条此字符的弧后，经过任意条<code>$$\epsilon$$</code>弧能到达的所有状态的集合</li><li>如果上述集合不在表的第一列，则将其加入第一列</li><li>重复上述步骤，直到没有新的集合</li><li>将所有集合标号，相同集合标相同的号，将其视为状态转换矩阵画出DFA</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-1.png"></p><h4 id="正规文法与有限自动机等价性"><a href="#正规文法与有限自动机等价性" class="headerlink" title="正规文法与有限自动机等价性"></a>正规文法与有限自动机等价性</h4><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-2.png"></p><p>对右线性文法，创建一个新状态f，所有文法中的非终结符经过其能推导到的非终结符左侧所有终结符组成的弧到达此非终结符。如果推导中不含非终结符，则将其连入f。</p><p>对有限自动机M，如果其终态可以射出一条弧到达出错处理状态，则任何连入此终态的弧，其对应的文法需要加入一个不含非终结符的推导。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-3.png"></p><p>左线性文法考虑每个状态射入的弧。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-4.png"></p><h4 id="正规式与有限自动机等价性"><a href="#正规式与有限自动机等价性" class="headerlink" title="正规式与有限自动机等价性"></a>正规式与有限自动机等价性</h4><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-5.png"></p><p>按上述规则分裂。</p><h4 id="DFA最小化"><a href="#DFA最小化" class="headerlink" title="DFA最小化"></a>DFA最小化</h4><p>寻找一个状态数比M少的DFA，使两个DFA等价。</p><p>把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。最后，让每个子集选出一个代表，同时消去其它状态。</p><h2 id="第四章-语法分析——自上而下分析"><a href="#第四章-语法分析——自上而下分析" class="headerlink" title="第四章 语法分析——自上而下分析"></a>第四章 语法分析——自上而下分析</h2><h3 id="上下文无关文法的定义"><a href="#上下文无关文法的定义" class="headerlink" title="上下文无关文法的定义"></a>上下文无关文法的定义</h3><p>一个上下文无关文法G是一个四元式<code>$$G=(V_T,V_N,S,P)$$</code>。</p><h3 id="语法分析的方法"><a href="#语法分析的方法" class="headerlink" title="语法分析的方法"></a>语法分析的方法</h3><p>自下而上分析法：从输入串开始，逐步进行归约，直到文法的开始符号。根据文法的产生式规则，把产生式的右部替换成左部符号。</p><p>自上而下分析法：从文法开始符号出发，利用各种产生式规则，寻找匹配的推导。</p><h4 id="自上而下分析面临的问题"><a href="#自上而下分析面临的问题" class="headerlink" title="自上而下分析面临的问题"></a>自上而下分析面临的问题</h4><p>分析过程中，可能走入暂时成功的匹配，后续会出错，需要回溯。<br>对于左递归的文法，会使得分析进入无限循环。</p><h3 id="LL-1-分析法"><a href="#LL-1-分析法" class="headerlink" title="LL(1)分析法"></a>LL(1)分析法</h3><h4 id="左递归的消除"><a href="#左递归的消除" class="headerlink" title="左递归的消除"></a>左递归的消除</h4><p>一般而言，假定P关于的全部产生式是<br><code>$$P\rightarrow Pa_1|Pa_2|...|Pa_m|b_1|b_2|...|b_n$$</code><br>那么，消除P的直接左递归就是把这个规则改写成<br><code>$$P\rightarrow b_1P&#39;|b_2P&#39;|...|b_nP&#39;$$</code><br><code>$$P&#39;\rightarrow a_1P&#39;|a_2P&#39;|...|a_mP&#39;|\epsilon $$</code></p><p>间接左递归也算左递归。</p><p>将间接左递归的推导代入，直到得到直接左递归的推导。然后改写成右递归形式，去除多余的规则即可。</p><h4 id="消除回溯，提左因子"><a href="#消除回溯，提左因子" class="headerlink" title="消除回溯，提左因子"></a>消除回溯，提左因子</h4><p>假定关于A的规则是<br><code>$$A\rightarrow \delta b_1|\delta b_2|...|\delta b_n|\gamma_1|\gamma_2|...|\gamma_m $$</code><br>那么可以把这些规则改写成<br><code>$$A\rightarrow \delta A&#39;|\gamma_1|\gamma_2|...|\gamma_m $$</code><br><code>$$A&#39;\rightarrow b_1|b_2|...|b_n $$</code></p><p>经过反复提取左因子，能把每个非终结符的所有候选首符集变成为两两不相交。</p><h4 id="FIRST、FOLLOW集合"><a href="#FIRST、FOLLOW集合" class="headerlink" title="FIRST、FOLLOW集合"></a>FIRST、FOLLOW集合</h4><p>令G是一个不含左递归的文法，对G的所有非终结符的每个候选a定义它的终结首符集FIRST(a)为下述字符组成的集合：</p><ul><li>所有能直接推出的最左终结符（包括<code>$$\epsilon $$</code>）</li><li>在文法中出现在此非终结符紧左的终结符</li><li>若某个推导中，最左侧为非终结符，此非终结符的FIRST集合的所有元素</li><li>如果上述最左的非终结符可以推出<code>$$\epsilon$$</code>，则考虑其紧右的符号，如是终结符，将其加入集合，如是非终结符，考虑第三条规则</li></ul><p>求出文法G的所有非终结符的FOLLOW集合为下述字符组成的集合：</p><ul><li>G中直接位于此非终结符紧右的终结符（对于开始符号，终止符属于FOLLOW集合）</li><li>G中直接位于此非终结符紧右的非终结符的FIRST集合的所有元素</li><li>若此非终结符位于一个推导的最右侧，此推导的源终结符的FOLLOW集合的所有元素</li></ul><p>如果一个文法不含左递归，每一个非终结符的各个推导的FIRST集合两两不相交，且对于每个非终结符A，若它存在某个候选首符集包含<code>$$\epsilon$$</code>，其FIRST集合和FOLLOW集合不相交，则称此文法为LL(1)文法。</p><h3 id="递归下降分析程序构造"><a href="#递归下降分析程序构造" class="headerlink" title="递归下降分析程序构造"></a>递归下降分析程序构造</h3><p>LL(1)文法可以构造递归下降分析程序。</p><p>递归下降分析程序的出错处理可以在主程序中统一执行，也可以在每个终结符对应的函数内部执行。</p><h3 id="预测分析程序"><a href="#预测分析程序" class="headerlink" title="预测分析程序"></a>预测分析程序</h3><p>又叫LL(1)分析法，包括：</p><ul><li>总控程序</li><li>分析表M[A,a]矩阵</li><li>分析栈，存放文法符号</li></ul><p>总控程序根据现行栈顶符号X和大当前输入符号a执行下列三种动作之一：</p><ul><li>若X&#x3D;a&#x3D;’#’，则宣布分析成功，停止分析</li><li>若X&#x3D;a不等于终止符，则把X从栈顶逐出，让a指向下一个输入符号</li><li>若X是一个非终结符，则查看分析表M</li><li><ul><li>若M中存放一个关于X的产生式，把X逐出战斗顶，把产生式的右部符号串按照反序一一推进栈</li></ul></li><li><ul><li>若对应出错，则调用ERROR</li></ul></li></ul><h4 id="构造分析表"><a href="#构造分析表" class="headerlink" title="构造分析表"></a>构造分析表</h4><p>首先构造每个非终结符A及其任意候选a的FIRST(a)和FOLLOW(A)集合。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-6.png"></p><p>利用上述集合构造分析表：</p><ul><li>对每个产生式执行2和3步</li><li>对每个终结符<code>$$a\in FIRST(a)$$</code>，把<code>$$A\rightarrow a$$</code>加入M[A,a]中</li><li>若<code>$$\epsilon \in FIRST(a)$$</code>，把任何<code>$$b\in FOLLOW(B)$$</code>把<code>$$A\rightarrow a$$</code>加入M[A,b]中</li><li>把所有无定义的M[A,a]加上出错标志</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-7.png"></p><p>如果G是左递归或二义的，那么，M至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M。一个文法G的预测分析表不含多定义入口，当且仅当该文法为LL(1)。</p><h2 id="第五章-语法分析——自下而上分析"><a href="#第五章-语法分析——自下而上分析" class="headerlink" title="第五章 语法分析——自下而上分析"></a>第五章 语法分析——自下而上分析</h2><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号。<br>自下而上的分析要解决的核心问题：<strong>识别可归约串</strong>。</p><h4 id="规范规约"><a href="#规范规约" class="headerlink" title="规范规约"></a>规范规约</h4><p>在一个句型对应的语法树中，以某非终结符为根的两代以上的子树的所有末端结点从左到右排列就是相对于该非终结符的一个短语，如果子树只有两代，则该短语就是直接短语。<br>最左直接短语就是句柄。</p><p>假定a是文法G的一个句子，我们称<code>$$a_n, a_&#123;n-1&#125;,...,a_0$$</code>是一个规范归约，如果：</p><ul><li><code>$$a_n = a$$</code></li><li><code>$$a_0$$</code>为文法的开始符号S</li><li>对任何i，<code>$$0 \leq i \leq n$$</code>，<code>$$a_&#123;i-1&#125;$$</code>是从<code>$$a_i$$</code>经把句柄替换成相应产生式左部符号得到的</li></ul><p>规范归约是最右推导的逆过程。由规范推导推出的句型称为规范句型。</p><h3 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h3><h4 id="LR分析器"><a href="#LR分析器" class="headerlink" title="LR分析器"></a>LR分析器</h4><p>LR分析器核心是分析表：</p><ul><li>ACTION[s,a]：当状态s面临符号a时，应采取什么动作</li><li>GOTO[s,X]：当状态s面临符号X时，下一个跳转的状态</li></ul><p>每一项ACTION的规定的四种动作：</p><ul><li>移进：把(s,a)的下一状态s’和输入符号a推进栈，下一输入符号变成现行输入符号</li><li>归约：利用某产生式<code>$$A\rightarrow b$$</code>归约，设b长度为r，归约动作是，去除栈顶r个项，使<code>$$s_&#123;m-r&#125;$$</code>变成栈顶状态，然后把下一状态s’&#x3D;GOTO[<code>$$s_&#123;m-r&#125;$$</code>, A]和文法符号A推进栈</li><li>接收：宣布分析成功</li><li>报错</li></ul><p>对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为LR文法。<br>一个文法，如果能用一个每步顶多向前检查k个输入符号的LR分析器进行分析，则这个文法就称为LR(k)文法。</p><h4 id="LR-0-项目集族和分析表构造"><a href="#LR-0-项目集族和分析表构造" class="headerlink" title="LR(0)项目集族和分析表构造"></a>LR(0)项目集族和分析表构造</h4><p>活前缀：指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。<br>LR分析就是保证栈中总是活前缀。</p><p>文法G的每个产生式的右部添加一个圆点称为G的LR(0)项目。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-8.png"></p><p>加入新初态称为唯一的接受态，形成拓广文法G’。</p><p>令每个项目集<code>$$I_k$$</code>的下标k作为分析器的状态，包含拓广文法的唯一接收态集合的下标k作为分析器初态。<br>根据DFA构造分析表，对每个箭弧：</p><ul><li>若箭弧标注非终结符a，对于箭弧起点状态S，终点状态S’，标注ACTION[S,a]&#x3D;sS’</li><li>若箭弧标注终结符A，对于箭弧起点状态S，终点状态S’，标注GOTO[S,A]&#x3D;S’</li><li>若状态存在归约项目（记归约用产生式顺序为N）</li><li><ul><li>状态为唯一接收态，标注ACTION[S,#]&#x3D;acc</li></ul></li><li><ul><li>状态不为唯一接收态，对每个终结符a（包括#），标注ACTION[S,a]&#x3D;rN</li></ul></li><li>其余区域填上报错标志</li></ul><h4 id="SLR分析表构造"><a href="#SLR分析表构造" class="headerlink" title="SLR分析表构造"></a>SLR分析表构造</h4><p>假定一个LR(0)规范族中含有如下的一个项目集状态<code>$$I=\&#123;X\rightarrow a·b\beta, A\rightarrow a·, B\rightarrow a·\&#125;$$</code>。A和B的FOLLOW集合交集为空，且不包含b，那么当状态I面临任何输入符号a时，可以：</p><ul><li>若a&#x3D;b则移进</li><li>若a属于A或B的FOLLOW集合，则用产生式A→a或B→a进行归约</li><li>此外，报错</li></ul><p>上述冲突性动作解决方案叫做SLR(1)解决办法。</p><p>SLR(1)分析表构造方法：</p><ul><li>若箭弧标注非终结符a，对于箭弧起点状态S，终点状态S’，标注ACTION[S,a]&#x3D;sS’</li><li>若箭弧标注终结符A，对于箭弧起点状态S，终点状态S’，标注GOTO[S,A]&#x3D;S’</li><li>若状态存在归约项目（记归约用产生式顺序为N）</li><li><ul><li>状态为唯一接收态，标注ACTION[S,#]&#x3D;acc</li></ul></li><li><ul><li>状态不为唯一接收态，对每个终结符a（包括#）**如果属于FOLLOW(A)**（与LR(0)不同），标注ACTION[S,a]&#x3D;rN</li></ul></li><li>其余区域填上报错标志</li></ul><p>SLR(1)利用FOLLOW获得的超前符号集合可能大于实际能出现的超前符号集合（很多文法并非SLR(1)）。也就是说，FOLLOW集合提供的信息太泛。</p><h4 id="LR-1-分析表构造"><a href="#LR-1-分析表构造" class="headerlink" title="LR(1)分析表构造"></a>LR(1)分析表构造</h4><p>项目集I的闭包CLOSURE(I)构造方法：</p><ul><li>I的任何项目都属于CLOSURE(I)</li><li>若项目<code>$$A\rightarrow \alpha·B\beta, a$$</code>属于CLOSURE(I)，<code>$$B\rightarrow \sigma$$</code>是一个产生式，那么对于<code>$$FIRST(\beta a)$$</code>中的每个终结符b，如果<code>$$B\rightarrow ·\sigma,b$$</code>原来不在CLOSURE(I)中，则加入</li><li>反复执行2，直到不能继续</li></ul><h4 id="LALR-1-构造"><a href="#LALR-1-构造" class="headerlink" title="LALR(1)构造"></a>LALR(1)构造</h4><p>合并LR(1)同心集后的项目集其核心部分不变，仅搜索符合并。</p><h2 id="第六章-属性文法和语法制导翻译"><a href="#第六章-属性文法和语法制导翻译" class="headerlink" title="第六章 属性文法和语法制导翻译"></a>第六章 属性文法和语法制导翻译</h2><h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><p>在上下文无关文法得到基础上，为每个文法符号配备若干相关的值。<br><strong>语义规则</strong>：对于文法的每个产生式都配备了一组属性的计算规则。</p><p>对于产生式的一套语义规则<code>$$b:=f(c1,c2,…,ck)$$</code>：</p><ul><li>b是A的综合属性，并且c是产生式右边文法符号的属性，或者A的其他属性</li><li>b是产生式右边某个文法符号的一个继承属性，并且c是A或产生式右边任何文法符号的属性</li></ul><p>终结符只有综合属性，由词法分析器提供。<br>非终结符既可有综合属性也可有继承属性，文法开始符号的所有继承属性作为属性计算前的初始值。<br>对出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性。<br>出现在产生式左边的继承属性和出现在产生式右边的综合属性不由所给的产生式的属性计算规则进行计算，它们由其它产生式的属性规则计算或者由属性计算器的参数提供。</p><h4 id="综合属性"><a href="#综合属性" class="headerlink" title="综合属性"></a>综合属性</h4><p>在语法树中，一个结点的综合属性的值由其子节点的属性值确定。使用自底向上的方法在每一个节点处使用语义规则计算综合属性的值。<br>仅使用综合属性的属性文法称为<strong>S-属性文法</strong>。</p><h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><p>在语法树中，一个结点的继承属性由此结点的父结点和&#x2F;或兄弟结点的某些属性确定。</p><h3 id="基于属性文法的处理方法"><a href="#基于属性文法的处理方法" class="headerlink" title="基于属性文法的处理方法"></a>基于属性文法的处理方法</h3><p>由源程序的语法结构所驱动的处理办法就是<strong>语法制导翻译法</strong>。</p><h4 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for 语法树中的每一结点n do</span><br><span class="line">for 结点n的文法符号的每一个属性a do</span><br><span class="line">为a在依赖图中建立一个结点;</span><br><span class="line"></span><br><span class="line">for 语法树中的每一个结点n do</span><br><span class="line">for 结点n所用产生式对应的每一个语义规则 b:=f do</span><br><span class="line">for i:=1 to k do</span><br><span class="line">从ci结点到b结点构造一条有向边;</span><br></pre></td></tr></table></figure><p>如果一属性文法不存在属性之间的循环依赖关系，那么称该文法为良定义的。</p><p>一个依赖图的任何拓扑排序都给出一个语法树中结点的语义规则计算的有效顺序。</p><h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><p>假设语法树已建立，且树中已带有开始符号的继承属性和终结符的综合属性。<br>以某种次序反复遍历语法树，计算出能计算的所有属性，直至计算出所有属性。</p><h4 id="一遍扫描"><a href="#一遍扫描" class="headerlink" title="一遍扫描"></a>一遍扫描</h4><p>语法分析的同时计算属性值。<br>L-属性文法适合于一遍扫描的自上而下分析。<br>S-属性文法适合于一遍扫描的自下而上分析。</p><p>所谓语法制导翻译法，直观上说就是为文法中每个产生式配上一组语义规则，并且在语法分析的同时执行这些语义规则。<br>语义规则被计算的时机：</p><ul><li>自上而下：产生式匹配输入串成功时</li><li>自下而上：产生式被用于进行归约时</li></ul><h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p>在语法树中去掉那些对翻译不必要的信息，从而获得更有效的源程序中间表示。这种经变换后的语法树称之为抽象语法树。</p><h3 id="S-属性文法的自下而上计算"><a href="#S-属性文法的自下而上计算" class="headerlink" title="S-属性文法的自下而上计算"></a>S-属性文法的自下而上计算</h3><p>S-属性文法：只含有综合属性。<br>分析器可以保存与栈中文法符号有关的综合属性值，每当进行归约时，新的属性值就由栈中正在归约的产生式右边符号的属性值来计算。</p><h3 id="L-属性文法和自顶向下翻译"><a href="#L-属性文法和自顶向下翻译" class="headerlink" title="L-属性文法和自顶向下翻译"></a>L-属性文法和自顶向下翻译</h3><p>通过深度优先的方法对语法树进行遍历，计算属性文法的所有属性值。<br>一个属性文法称为L-属性文法，如果对于每个产生式<code>$$A\rightarrow X_1X_2...X_n$$</code>，其每个语义规则中的每个属性或者是综合属性，或者是继承属性，这个继承属性仅依赖于：</p><ul><li>其左侧符号的属性</li><li>A的继承属性</li></ul><p>由于S-属性文法仅含综合属性，所以它一定是L-属性文法。</p><h4 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h4><p>给出了使用语义规则进行计算的次序，这样就可把某些实现细节表示出来。</p><p>设计翻译模式时，必须保证当某个动作引用一个属性时它必须是有定义的。L-属性文法确保了这一点。</p><p>当只需要综合属性时：为每一个语义规则建立一个包含赋值的动作，并把这个动作放在相应的产生式右边的末尾。<br>如果既需要综合属性又需要继承属性，则要保证：</p><ul><li>产生式右边符号的继承属性必须在这个符号以前的动作计算出来</li><li>一个动作不能引用这个动作右边符号的综合属性</li><li>左边非终结符得到综合属性必须在引用的所有属性计算出来后才能计算，动作放在右端末尾可以解决大部分情况的问题</li></ul><h4 id="自顶向下翻译"><a href="#自顶向下翻译" class="headerlink" title="自顶向下翻译"></a>自顶向下翻译</h4><p>消除左递归，构造新的翻译模式。<br><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-9.png"></p><h4 id="递归下降翻译器的设计"><a href="#递归下降翻译器的设计" class="headerlink" title="递归下降翻译器的设计"></a>递归下降翻译器的设计</h4><p>对每个非终结符A构造一个函数过程，对A的每个继承属性设置一个形式参数。<br>函数的返回值为A的综合属性（作为记录，或指向记录的一个指针，记录中有若干域，每个属性对应一个域）。为了简单，我们假设每个非终结只有一个综合属性。<br>A对应的函数过程中，为出现在A的产生式中的每一个文法符号的每一个属性都设置一个局部变量。</p><p>非终结符A对应的函数过程中，根据当前的输入符号决定使用哪个产生式候选。</p><p>每个产生式对应的程序代码中，按照从左到右的次序，对于单词符号（终结符）、非终结符和语义动作分别作以下工作：</p><ul><li>对带有综合属性x的终结符X，把x的值存入为X.x设置的变量中。然后产生一个匹配X的调用，并继续读入一个输入符号。</li><li>对于每个非终结符B，产生一个右边带有函数调用的赋值语句</li><li>对于语义动作，把动作的代码抄进分析器中，用代表属性的变量来代替对属性的每一次引用</li></ul><h2 id="第七章-语义分析和中间代码产生"><a href="#第七章-语义分析和中间代码产生" class="headerlink" title="第七章 语义分析和中间代码产生"></a>第七章 语义分析和中间代码产生</h2><h3 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h3><h4 id="后缀式"><a href="#后缀式" class="headerlink" title="后缀式"></a>后缀式</h4><p>又称逆波兰表示法。可以如下定义：</p><ul><li>对表达式E，如果E是一个常量或变量，则E的后缀式就是E本身</li><li>如果E是E1 op E2形式的表达式，其中op是任何二元操作符，则E的后缀式为E1’ E2’ op，其中E1’ E2’为E1和E2的后缀式</li><li>如果E是(E)形式的表达式，那么E后缀式是本身</li></ul><p>后缀式的计算用栈实现，自左至右扫描后缀式，每碰到运算量就把它推进栈。每碰到k目运算符就把它作用于栈顶的k个项，并用运算结果代替这k个项。</p><h4 id="图表示法"><a href="#图表示法" class="headerlink" title="图表示法"></a>图表示法</h4><p>无循环有向图(DAG)：</p><ul><li>对表达式中的每个子表达式，DAG中都有一个结点</li><li>一个内部节点代表一个操作符，它的子结点代表操作数</li><li>在一个DAG中代表公共子表达式的结点具有多个父节点</li></ul><h4 id="三地址代码"><a href="#三地址代码" class="headerlink" title="三地址代码"></a>三地址代码</h4><p>形如x:&#x3D;y op z，可以看成是抽象语法树或DAG的一种线性表示。</p><p><strong>三地址语句的种类</strong>：</p><ul><li>x:&#x3D;y op z</li><li>x:&#x3D;op y</li><li>x:&#x3D;y</li><li>goto L</li><li>if x relop y goto L &#x2F; if a goto L</li><li>param x &#x2F; call p, n &#x2F; return y</li><li>x:&#x3D;y[i] &#x2F; x[i]:&#x3D;y</li><li>x:&#x3D;&amp;y &#x2F; x:&#x3D;*y &#x2F; *x:&#x3D;y</li></ul><p>生成三地址代码时，临时变量的名字对应抽象语法树的内部结点。</p><h5 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h5><p>四个域的记录结构，域分别为：</p><ul><li>操作符</li><li>操作数1</li><li>操作数2</li><li>结果</li></ul><h5 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h5><p>通过计算临时变量值的语句的位置来引用这个临时变量。<br>三个域：</p><ul><li>操作符</li><li>操作数1</li><li>操作数2</li></ul><h5 id="间接三元式"><a href="#间接三元式" class="headerlink" title="间接三元式"></a>间接三元式</h5><p>用三元式表和间接码表来表示中间代码。</p><h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><h4 id="简单算术表达式及赋值语句"><a href="#简单算术表达式及赋值语句" class="headerlink" title="简单算术表达式及赋值语句"></a>简单算术表达式及赋值语句</h4><p>非终结符号E有如下两个属性：</p><ul><li>E.place表示存放E值的名字</li><li>E.code表示对E求值的三地址语句序列<br>函数newtemp的功能是，每次调用它时，将返回一个不同临时变量名字,如T1,T2,…。</li></ul><p>非终结符号S有综合属性S.code，它代表赋值语句S的三地址代码。</p><h4 id="数组元素的引用"><a href="#数组元素的引用" class="headerlink" title="数组元素的引用"></a>数组元素的引用</h4><p>元素A[i1,i2,…,ik]的相对地址公式：<br><code>$$((...(i_1n_2+i_2)n_3+i_3)...)n_k+i_k)×w+base-((...((low_1n_2+low_2)n_3+low_3)...)n_k+low_k)×w$$</code><br><code>$$c = base-((...((low_1n_2+low_2)n_3+low_3)...)n_k+low_k)×w$$</code></p><p>引入下列语义变量或语义过程：</p><ul><li>Elist.ndim：下标个数计数器</li><li>Elist.place：表示临时变量，临时存放已形成的Elist中的下表表达式计算出来的值</li><li>limit(array, j)：给出数组array第j维的长度</li></ul><h3 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h3><p>布尔表达式有两种计算方法：</p><ul><li>按照算术表达式的计算方法，一步步算</li><li>用if-else语句解释</li></ul><p>过程emit将三地址代码送到输出文件中，nextstat给出输出序列中下一条三地址语句的地址索引，每产生一条三地址语句，过程emit把nextstat加1。</p><p><strong>两遍扫描</strong>：为给定的输入串构造一棵语法树，深度优先遍历，按照语义规则翻译。</p><p><strong>一遍扫描</strong>：采用四元式形式，四元式存入一个数组中，下标代表标号。</p><p>约定：</p><ul><li>(jnz, a, - ,p)：if a goto p</li><li>(jrop, x, y, p)： if x rop y goto p</li><li>(j, -, -, p)： goto p</li></ul><p>有时转移地址无法立即知道，需要回填。</p><h2 id="第九章-运行时存储空间组织"><a href="#第九章-运行时存储空间组织" class="headerlink" title="第九章 运行时存储空间组织"></a>第九章 运行时存储空间组织</h2><h3 id="目标程序运行时的活动"><a href="#目标程序运行时的活动" class="headerlink" title="目标程序运行时的活动"></a>目标程序运行时的活动</h3><p>过程P一个活动的生存期，指的是从执行该过程体第一步操作到最后一步操作之间的操作序，包括执行P时调用其它过程花费的时间。</p><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><h5 id="传地址-Call-by-reference"><a href="#传地址-Call-by-reference" class="headerlink" title="传地址 Call by reference"></a>传地址 Call by reference</h5><p>过程体对形式参数的引用域赋值被处理成对形式单元的间接访问。</p><h5 id="得结果-Call-by-result"><a href="#得结果-Call-by-result" class="headerlink" title="得结果 Call by result"></a>得结果 Call by result</h5><p>形参有两个单元，第一个单元存地址，第二个单元存值。在过程体中，引用第二个单元，在结束后将计算后的值回填到第一个单元的地址中。</p><h5 id="传值-Call-by-value"><a href="#传值-Call-by-value" class="headerlink" title="传值 Call by value"></a>传值 Call by value</h5><p>只传值，不传地址。过程体对形参的操作不会影响实际参数。</p><h5 id="传名-Call-by-name"><a href="#传名-Call-by-name" class="headerlink" title="传名 Call by name"></a>传名 Call by name</h5><p>把过程的代码抄到被调用的位置，形参全部被替换成实参。</p><h3 id="运行时存储器的划分"><a href="#运行时存储器的划分" class="headerlink" title="运行时存储器的划分"></a>运行时存储器的划分</h3><p>一个目标程序运行所需的存储空间包括：</p><ul><li>存放目标代码的空间</li><li>存放数据的空间</li><li>存放程序运行的控制或连接数据所需单元（控制栈）</li></ul><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-10.png"></p><h4 id="活动记录"><a href="#活动记录" class="headerlink" title="活动记录"></a>活动记录</h4><p>假定语言的特点为:允许过程递归调用、允许过程含有可变数组，但过程定义不允许嵌套，如C语言。</p><p>活动记录：运行时，每当进入一个过程就有一个相应的活动记录置于栈顶。此记录含有连接数据、形式单元、局部变量、局部数组的内情向量和临时工作单元等。</p><h4 id="存储分配策略"><a href="#存储分配策略" class="headerlink" title="存储分配策略"></a>存储分配策略</h4><p>**静态分配策略(FORTRAN)**：如果在编译时能确定数据空间的大小，则可采用静态分配方法：在编译时刻为每个数据项目确定出在运行时刻的存储空间中的位置。<br>**动态分配策略(PASCAL)**：如果在编译时不能确定运行时数据空间的大小，则必须采用动态分配方法。允许递归过程和动态申请释放内存。</p><h3 id="静态存储管理"><a href="#静态存储管理" class="headerlink" title="静态存储管理"></a>静态存储管理</h3><p>由于每个FORTRAN程序段可以独立编译，运行前由装入程序把各段连成可运行的整体。通常按数据区组织存储:</p><ul><li>每个程序段定义一个局部数据区，用来存放程序段中未出现在COMMON里的局部名的值</li><li>每个公用块定义一个公用数据区，用来存放公用块里各个名字的值</li></ul><h3 id="一个简单栈式存储分配"><a href="#一个简单栈式存储分配" class="headerlink" title="一个简单栈式存储分配"></a>一个简单栈式存储分配</h3><h4 id="C的活动记录"><a href="#C的活动记录" class="headerlink" title="C的活动记录"></a>C的活动记录</h4><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-11.png"></p><h4 id="C的过程调用、过程进入、数组空间分配和过程返回"><a href="#C的过程调用、过程进入、数组空间分配和过程返回" class="headerlink" title="C的过程调用、过程进入、数组空间分配和过程返回"></a>C的过程调用、过程进入、数组空间分配和过程返回</h4><p>过程调用的四元式序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">par T1</span><br><span class="line">par T2</span><br><span class="line">...</span><br><span class="line">par Tn</span><br><span class="line">call P, n</span><br></pre></td></tr></table></figure><p>par表示传参，call表示调用。</p><p>每个par Ti可以直接翻译成如下指令：</p><ul><li>(i+3)[TOP]:&#x3D;Ti 将Ti的值存储到TOP+i+3的地址上</li><li>(i+3)[TOP]:&#x3D;addr(Ti) 将Ti的地址存储到TOP+i+3的地址上</li></ul><p>call P, n被翻译成：</p><ul><li>1[TOP]:&#x3D;SP 保护现SP</li><li>3[TOP]:&#x3D;n 传递参数个数为n</li><li>JSP P 跳转子指令</li></ul><p>转进过程P后，首先应执行下述指令:</p><ul><li>SP:&#x3D;TOP+1</li><li>1[SP]:&#x3D;返回地址</li><li>TOP:&#x3D;TOP+L L是过程P活动记录需要的单元数</li></ul><p>过程返回时，应执行下列指令:</p><ul><li>TOP:&#x3D;SP-1 恢复调用前TOP</li><li>SP:&#x3D;0[SP] 恢复调用前SP</li><li>X:&#x3D;2[TOP] 把返回地址取到X</li><li>UJ 0[X] 按X返回</li></ul><h3 id="嵌套过程语言的栈式实现"><a href="#嵌套过程语言的栈式实现" class="headerlink" title="嵌套过程语言的栈式实现"></a>嵌套过程语言的栈式实现</h3><p>假定语言不仅允许过程的递归调用(和可变数组)，而且允许过程定义的嵌套，如PASCAL，PL语言。</p><h4 id="非局部名字的访问的实现"><a href="#非局部名字的访问的实现" class="headerlink" title="非局部名字的访问的实现"></a>非局部名字的访问的实现</h4><p>主程序的层次为0；在i层中定义的过程，其层次为i+1;<br>过程运行时，必须知道其所有外层过程的当前活动记录的起始地址。</p><h5 id="静态链和活动记录"><a href="#静态链和活动记录" class="headerlink" title="静态链和活动记录"></a>静态链和活动记录</h5><p><strong>静态链</strong>：指向本过程的<strong>直接外层过程</strong>的活动记录的起始地址，也称存取链。<br><strong>动态链</strong>：指向本过程的<strong>调用过程</strong>的活动记录的起始地址，也称控制链。</p><p>活动记录从下至上依次为：</p><ul><li>动态链</li><li>返回地址</li><li>静态链</li><li>参数个数</li><li>形式单元</li><li>变量等过程内部信息</li></ul><h5 id="嵌套层次显示表display"><a href="#嵌套层次显示表display" class="headerlink" title="嵌套层次显示表display"></a>嵌套层次显示表display</h5><p>当进入一个过程后，在建立其活动记录区的同时建立一张嵌套层次显示表display，把display表作为活动记录的一部分。</p><p>假设过程R的外层为Q，Q外层为主程序P，则过程R的运行时DISPLAY表内容为：</p><ul><li>2 R现行活动记录地址 SP现值</li><li>1 Q的最新活动记录地址</li><li>0 P的活动记录地址</li></ul><h5 id="PL全局display表"><a href="#PL全局display表" class="headerlink" title="PL全局display表"></a>PL全局display表</h5><p>记录结构：</p><ul><li>RA</li><li>DL</li><li>SL</li><li>形式单元</li></ul><p>通过全局display表找到活动记录。<br>display表的1层放主程序记录RA，第二层放最新调用的所有于主程序层次差为1的过程记录RA，第三层层次差为2，以此类推。</p><h2 id="第十章-优化"><a href="#第十章-优化" class="headerlink" title="第十章 优化"></a>第十章 优化</h2><p>对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。</p><p>优化的目的是为了产生更高效的代码。由优化编译程序提供的对代码的各种变换必须遵循一定的原则：</p><ul><li>等价原则：经过优化后不应改变程序运行的结果；</li><li>有效原则：使优化后所产生的目标代码运行时间较短，占用的存储空间较小；</li><li>合算原则：应尽可能以较低的代价取得较好的优化效果。</li></ul><p>三个不同级别：</p><ul><li>局部优化</li><li>循环优化</li><li>全局优化</li></ul><p>种类：</p><ul><li>删除多与运算</li><li>代码外提</li><li>强度削弱</li><li>变换循环控制条件</li><li>合并已知量</li><li>复写传播</li><li>删除无用赋值</li></ul><h3 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h3><p>基本块：指程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句。</p><p>如果一条三地址语句为x:&#x3D;y+z，则称对x定值并引用y和z。</p><p>局限于基本块范围内的优化称为基本块内的优化，或称局部优化。</p><h4 id="划分基本块"><a href="#划分基本块" class="headerlink" title="划分基本块"></a>划分基本块</h4><p>求出四元式程序中各个基本块的入口语句:</p><ol><li>程序第一个语句，或</li><li>能由条件转移语句或无条件转移语句转移到的语句，或</li><li>紧跟在条件转移语句后面的语句。</li></ol><p>对以上求出的每个入口语句，确定其所属的基本块。它是由该入口语句到下一入口语句(不包括该入口语句)、或到一转移语句(包括该转移语句)、或一停语句(包括该停语句)之间的语句序列组成的。</p><p>凡未被纳入某一基本块中的语句，可以从程序中删除。</p><h4 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h4><p>每个流图以基本块为结点。如果一个结点的基本块的入口语句是程序的第一条语句，则称此结点为首结点。如果在某个执行顺序中，基本块B2紧接在基本块B1之后执行，则从B1到B2有一条有向边。</p><p><img src="https://www.nemotte.cn/wordpress/wp-content/uploads/2023/03/QQ%E6%88%AA%E5%9B%BE20230618083610-12.png"></p><p>描述计算过程的DAG是一种带有下述标记或附加信息的DAG：<br>图的叶结点以一标识符或常数作为标记，表示该结点代表该变量或常数的值;<br>图的内部结点以一运算符作为标记，表示该结点代表应用该运算符对其后继结点所代表的值进行运算的结果;</p>]]></content>
      
      
      <categories>
          
          <category> 计科专业课笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
